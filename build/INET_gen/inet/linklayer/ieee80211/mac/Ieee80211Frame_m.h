//
// Generated file, do not edit! Created by nedtool 5.7 from /home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg.
//

#ifndef __INET__IEEE80211_IEEE80211FRAME_M_H
#define __INET__IEEE80211_IEEE80211FRAME_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0507
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include "inet/linklayer/common/MACAddress.h"
#include "inet/linklayer/common/Ieee802Ctrl_m.h" // for ~EtherType
#include "inet/common/BitVector.h"
// }}


namespace inet {
namespace ieee80211 {

// cplusplus {{
const unsigned int LENGTH_RTS = 160;    //bits
const unsigned int LENGTH_CTS = 112;    //bits
const unsigned int LENGTH_ACK = 112;    //bits
const unsigned int LENGTH_MGMT = 28 * 8;    //bits
const unsigned int LENGTH_ADDBAREQ = LENGTH_MGMT + 9*8; // mgmt length + action body length
const unsigned int LENGTH_BASIC_BLOCKACK = (16 + 2 + (2 + 128) + 4) * 8; // header + ba control + ba information + fcs
const unsigned int DATAFRAME_HEADER_MINLENGTH = 28 * 8;    //bits without QoS, without Address4, without SNAP: 2 + 2 + 3*6(addresses) + 2 + 4(crc)
const unsigned int QOSCONTROL_BITS = 2 * 8;    // QoS Control field length (bits)
const unsigned int SNAP_HEADER_BYTES = 8;
const short int MAX_NUM_FRAGMENTS = 16;
const unsigned int LENGTH_A_MSDU_SUBFRAME_HEADER = 14 * 8; //48 + 48 + 16 bits
// }}

/**
 * Enum generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:53</tt> by nedtool.
 * <pre>
 * //
 * // 802.11 frame type constants (type+subtype), for the "type" field of
 * // Ieee80211FrameControl
 * //
 * enum Ieee80211FrameType
 * {
 *     // management:
 *     ST_ASSOCIATIONREQUEST = 0x00;
 *     ST_ASSOCIATIONRESPONSE = 0x01;
 *     ST_REASSOCIATIONREQUEST = 0x02;
 *     ST_REASSOCIATIONRESPONSE = 0x03;
 *     ST_PROBEREQUEST = 0x04;
 *     ST_PROBERESPONSE = 0x05;
 *     ST_BEACON = 0x08;
 *     ST_ATIM = 0x09;
 *     ST_DISASSOCIATION = 0x0a;
 *     ST_AUTHENTICATION = 0x0b;
 *     ST_DEAUTHENTICATION = 0x0c;
 *     ST_ACTION = 0x0d;
 *     ST_NOACKACTION = 0x0e;
 * 
 *     // control (CFEND/CFEND_CFACK omitted):
 *     ST_PSPOLL = 0x1a;
 *     ST_RTS = 0x1b;
 *     ST_CTS = 0x1c;
 *     ST_ACK = 0x1d;
 *     ST_BLOCKACK_REQ = 0x18;
 *     ST_BLOCKACK = 0x19;
 * 
 *     // data (CFPOLL/CFACK subtypes omitted):
 *     ST_DATA = 0x20;
 *     ST_DATA_WITH_QOS = 0x28;
 *     //Feedback frame for multicast tramsmission
 *     ST_LBMS_REQUEST = 0x30;
 *     ST_LBMS_REPORT = 0x31;
 * }
 * </pre>
 */
enum Ieee80211FrameType {
    ST_ASSOCIATIONREQUEST = 0x00,
    ST_ASSOCIATIONRESPONSE = 0x01,
    ST_REASSOCIATIONREQUEST = 0x02,
    ST_REASSOCIATIONRESPONSE = 0x03,
    ST_PROBEREQUEST = 0x04,
    ST_PROBERESPONSE = 0x05,
    ST_BEACON = 0x08,
    ST_ATIM = 0x09,
    ST_DISASSOCIATION = 0x0a,
    ST_AUTHENTICATION = 0x0b,
    ST_DEAUTHENTICATION = 0x0c,
    ST_ACTION = 0x0d,
    ST_NOACKACTION = 0x0e,
    ST_PSPOLL = 0x1a,
    ST_RTS = 0x1b,
    ST_CTS = 0x1c,
    ST_ACK = 0x1d,
    ST_BLOCKACK_REQ = 0x18,
    ST_BLOCKACK = 0x19,
    ST_DATA = 0x20,
    ST_DATA_WITH_QOS = 0x28,
    ST_LBMS_REQUEST = 0x30,
    ST_LBMS_REPORT = 0x31
};

/**
 * Enum generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:89</tt> by nedtool.
 * <pre>
 * //
 * // Ack policy values for the 802.11 QoS control field
 * //
 * enum AckPolicy
 * {
 *     NORMAL_ACK = 0;
 *     NO_ACK = 1;
 *     NO_EXPLICIT_ACK = 2;
 *     BLOCK_ACK = 3;
 * }
 * </pre>
 */
enum AckPolicy {
    NORMAL_ACK = 0,
    NO_ACK = 1,
    NO_EXPLICIT_ACK = 2,
    BLOCK_ACK = 3
};

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:105</tt> by nedtool.
 * <pre>
 * //
 * // The common part of 802.11 frames.
 * //
 * // NOTE:
 * // FCS value is not explicitly modeled, but it is included in the length.
 * // Frame control format fields not supported by this model are omitted:
 * // MoreFlag, PowerMgmt, MoreData, WEP, Order.
 * //
 * packet Ieee80211Frame
 * {
 *     byteLength = LENGTH_ACK / 8;
 *     short type \@enum(Ieee80211FrameType); // type and subtype
 *     bool toDS;
 *     bool fromDS;
 *     bool retry;
 *     bool moreFragments;
 *     // TODO: rename to durationField (levy)
 *     simtime_t duration = -1; // "duration" in the Duration/ID field (-1=no duration)
 *     short AID = -1;          // "id" (Association ID) in the Duration/ID field (-1=no ID)
 *     MACAddress receiverAddress; // aka address1
 *     simtime_t MACArrive;    // FIXME remove it, technical data, used inside of MAC module
 * }
 * </pre>
 */
class Ieee80211Frame : public ::omnetpp::cPacket
{
  protected:
    short type;
    bool toDS;
    bool fromDS;
    bool retry;
    bool moreFragments;
    ::omnetpp::simtime_t duration;
    short AID;
    MACAddress receiverAddress;
    ::omnetpp::simtime_t MACArrive;

  private:
    void copy(const Ieee80211Frame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211Frame&);

  public:
    Ieee80211Frame(const char *name=nullptr, short kind=0);
    Ieee80211Frame(const Ieee80211Frame& other);
    virtual ~Ieee80211Frame();
    Ieee80211Frame& operator=(const Ieee80211Frame& other);
    virtual Ieee80211Frame *dup() const override {return new Ieee80211Frame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual short getType() const;
    virtual void setType(short type);
    virtual bool getToDS() const;
    virtual void setToDS(bool toDS);
    virtual bool getFromDS() const;
    virtual void setFromDS(bool fromDS);
    virtual bool getRetry() const;
    virtual void setRetry(bool retry);
    virtual bool getMoreFragments() const;
    virtual void setMoreFragments(bool moreFragments);
    virtual ::omnetpp::simtime_t getDuration() const;
    virtual void setDuration(::omnetpp::simtime_t duration);
    virtual short getAID() const;
    virtual void setAID(short AID);
    virtual MACAddress& getReceiverAddress();
    virtual const MACAddress& getReceiverAddress() const {return const_cast<Ieee80211Frame*>(this)->getReceiverAddress();}
    virtual void setReceiverAddress(const MACAddress& receiverAddress);
    virtual ::omnetpp::simtime_t getMACArrive() const;
    virtual void setMACArrive(::omnetpp::simtime_t MACArrive);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211Frame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211Frame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:123</tt> by nedtool.
 * <pre>
 * //
 * // Format of a 802.11 frame with address1 present, like ACK and CTS
 * //
 * packet Ieee80211OneAddressFrame extends Ieee80211Frame
 * {
 * }
 * </pre>
 */
class Ieee80211OneAddressFrame : public ::inet::ieee80211::Ieee80211Frame
{
  protected:

  private:
    void copy(const Ieee80211OneAddressFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211OneAddressFrame&);

  public:
    Ieee80211OneAddressFrame(const char *name=nullptr, short kind=0);
    Ieee80211OneAddressFrame(const Ieee80211OneAddressFrame& other);
    virtual ~Ieee80211OneAddressFrame();
    Ieee80211OneAddressFrame& operator=(const Ieee80211OneAddressFrame& other);
    virtual Ieee80211OneAddressFrame *dup() const override {return new Ieee80211OneAddressFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211OneAddressFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211OneAddressFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:130</tt> by nedtool.
 * <pre>
 * //
 * // Format of the 802.11 ACK frame
 * //
 * packet Ieee80211ACKFrame extends Ieee80211OneAddressFrame
 * {
 *     byteLength = LENGTH_ACK / 8;
 *     type = ST_ACK;
 * }
 * </pre>
 */
class Ieee80211ACKFrame : public ::inet::ieee80211::Ieee80211OneAddressFrame
{
  protected:

  private:
    void copy(const Ieee80211ACKFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ACKFrame&);

  public:
    Ieee80211ACKFrame(const char *name=nullptr, short kind=0);
    Ieee80211ACKFrame(const Ieee80211ACKFrame& other);
    virtual ~Ieee80211ACKFrame();
    Ieee80211ACKFrame& operator=(const Ieee80211ACKFrame& other);
    virtual Ieee80211ACKFrame *dup() const override {return new Ieee80211ACKFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211ACKFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211ACKFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:139</tt> by nedtool.
 * <pre>
 * //
 * // Format of a 802.11 frame with address1 and address2 present
 * //
 * packet Ieee80211TwoAddressFrame extends Ieee80211OneAddressFrame
 * {
 *     byteLength = LENGTH_RTS / 8;
 *     MACAddress transmitterAddress; // aka address2
 * }
 * </pre>
 */
class Ieee80211TwoAddressFrame : public ::inet::ieee80211::Ieee80211OneAddressFrame
{
  protected:
    MACAddress transmitterAddress;

  private:
    void copy(const Ieee80211TwoAddressFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211TwoAddressFrame&);

  public:
    Ieee80211TwoAddressFrame(const char *name=nullptr, short kind=0);
    Ieee80211TwoAddressFrame(const Ieee80211TwoAddressFrame& other);
    virtual ~Ieee80211TwoAddressFrame();
    Ieee80211TwoAddressFrame& operator=(const Ieee80211TwoAddressFrame& other);
    virtual Ieee80211TwoAddressFrame *dup() const override {return new Ieee80211TwoAddressFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual MACAddress& getTransmitterAddress();
    virtual const MACAddress& getTransmitterAddress() const {return const_cast<Ieee80211TwoAddressFrame*>(this)->getTransmitterAddress();}
    virtual void setTransmitterAddress(const MACAddress& transmitterAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211TwoAddressFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211TwoAddressFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:148</tt> by nedtool.
 * <pre>
 * //
 * // Format of the 802.11 RTS frame
 * //
 * packet Ieee80211RTSFrame extends Ieee80211TwoAddressFrame
 * {
 *     byteLength = LENGTH_RTS / 8;
 *     type = ST_RTS;
 * }
 * </pre>
 */
class Ieee80211RTSFrame : public ::inet::ieee80211::Ieee80211TwoAddressFrame
{
  protected:

  private:
    void copy(const Ieee80211RTSFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211RTSFrame&);

  public:
    Ieee80211RTSFrame(const char *name=nullptr, short kind=0);
    Ieee80211RTSFrame(const Ieee80211RTSFrame& other);
    virtual ~Ieee80211RTSFrame();
    Ieee80211RTSFrame& operator=(const Ieee80211RTSFrame& other);
    virtual Ieee80211RTSFrame *dup() const override {return new Ieee80211RTSFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211RTSFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211RTSFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:157</tt> by nedtool.
 * <pre>
 * //
 * // Format of the 802.11 CTS frame
 * //
 * packet Ieee80211CTSFrame extends Ieee80211OneAddressFrame
 * {
 *     byteLength = LENGTH_CTS / 8;
 *     type = ST_CTS;
 * }
 * </pre>
 */
class Ieee80211CTSFrame : public ::inet::ieee80211::Ieee80211OneAddressFrame
{
  protected:

  private:
    void copy(const Ieee80211CTSFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211CTSFrame&);

  public:
    Ieee80211CTSFrame(const char *name=nullptr, short kind=0);
    Ieee80211CTSFrame(const Ieee80211CTSFrame& other);
    virtual ~Ieee80211CTSFrame();
    Ieee80211CTSFrame& operator=(const Ieee80211CTSFrame& other);
    virtual Ieee80211CTSFrame *dup() const override {return new Ieee80211CTSFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211CTSFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211CTSFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:166</tt> by nedtool.
 * <pre>
 * //
 * // Common base class for 802.11 data and management frames
 * //
 * packet Ieee80211DataOrMgmtFrame extends Ieee80211TwoAddressFrame
 * {
 *     byteLength = LENGTH_MGMT / 8;
 *     MACAddress address3;
 *     short fragmentNumber;
 *     uint16 sequenceNumber;
 * }
 * </pre>
 */
class Ieee80211DataOrMgmtFrame : public ::inet::ieee80211::Ieee80211TwoAddressFrame
{
  protected:
    MACAddress address3;
    short fragmentNumber;
    uint16_t sequenceNumber;

  private:
    void copy(const Ieee80211DataOrMgmtFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211DataOrMgmtFrame&);

  public:
    Ieee80211DataOrMgmtFrame(const char *name=nullptr, short kind=0);
    Ieee80211DataOrMgmtFrame(const Ieee80211DataOrMgmtFrame& other);
    virtual ~Ieee80211DataOrMgmtFrame();
    Ieee80211DataOrMgmtFrame& operator=(const Ieee80211DataOrMgmtFrame& other);
    virtual Ieee80211DataOrMgmtFrame *dup() const override {return new Ieee80211DataOrMgmtFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual MACAddress& getAddress3();
    virtual const MACAddress& getAddress3() const {return const_cast<Ieee80211DataOrMgmtFrame*>(this)->getAddress3();}
    virtual void setAddress3(const MACAddress& address3);
    virtual short getFragmentNumber() const;
    virtual void setFragmentNumber(short fragmentNumber);
    virtual uint16_t getSequenceNumber() const;
    virtual void setSequenceNumber(uint16_t sequenceNumber);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211DataOrMgmtFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211DataOrMgmtFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:177</tt> by nedtool.
 * <pre>
 * //
 * // Format of the 802.11 data frame
 * //
 * packet Ieee80211DataFrame extends Ieee80211DataOrMgmtFrame
 * {
 *     //  The presence of the Address 4 field is determined by the setting of the To DS and From DS subfields of
 *     //  the Frame Control field (see below). The QoS Control field is present when the QoS subfield of the Subtype
 *     //  field is set to 1 (8.3.2.1 Data frame format)
 *     //  FIXME: byteLength is not a constant value (DATAFRAME_HEADER_MINLENGTH / 8 = 28).
 *     //  For example, with Address 4 and without QoS the correct length is 34 bytes.
 *     //  Without Address 4 and QoS the correct value is indeed 28.
 *     //  With Address 4 and QoS the correct value is indeed 36.
 *     byteLength = DATAFRAME_HEADER_MINLENGTH / 8;
 *     type = ST_DATA;         // or ST_DATA_WITH_QOS
 *     MACAddress address4;    // optional field, exists when toDS and fromDS are true
 *     uint16 qos;             // TODO nobody uses this currently, only its parts like tid below... 
 *     int ackPolicy \@enum(AckPolicy); //FIXME in real life this is part of the optional qos field above...
 *     uint8 tid; //FIXME in real life this is part of the optional qos field above...
 *     bool aMsduPresent = false; // 8.2.4.5.9 A-MSDU Present subfield FIXME in real life this is part of the optional qos field above...
 * }
 * 
 * //TODO this can be introduced when the SNAP header 
 * //packet Ieee80211QoSDataFrame extends Ieee80211DataFrame
 * //{
 * //    type = ST_DATA_WITH_QOS;
 * //    byteLength = (DATAFRAME_HEADER_MINLENGTH + QOSCONTROL_BITS) / 8;
 * //    int ackPolicy \@enum(AckPolicy); //FIXME in real life this is part of the optional qos field above...
 * //    uint8 tid;
 * //    // TODO: other QoS control field parts
 * //}
 * </pre>
 */
class Ieee80211DataFrame : public ::inet::ieee80211::Ieee80211DataOrMgmtFrame
{
  protected:
    MACAddress address4;
    uint16_t qos;
    int ackPolicy;
    uint8_t tid;
    bool aMsduPresent;

  private:
    void copy(const Ieee80211DataFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211DataFrame&);

  public:
    Ieee80211DataFrame(const char *name=nullptr, short kind=0);
    Ieee80211DataFrame(const Ieee80211DataFrame& other);
    virtual ~Ieee80211DataFrame();
    Ieee80211DataFrame& operator=(const Ieee80211DataFrame& other);
    virtual Ieee80211DataFrame *dup() const override {return new Ieee80211DataFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual MACAddress& getAddress4();
    virtual const MACAddress& getAddress4() const {return const_cast<Ieee80211DataFrame*>(this)->getAddress4();}
    virtual void setAddress4(const MACAddress& address4);
    virtual uint16_t getQos() const;
    virtual void setQos(uint16_t qos);
    virtual int getAckPolicy() const;
    virtual void setAckPolicy(int ackPolicy);
    virtual uint8_t getTid() const;
    virtual void setTid(uint8_t tid);
    virtual bool getAMsduPresent() const;
    virtual void setAMsduPresent(bool aMsduPresent);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211DataFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211DataFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:208</tt> by nedtool.
 * <pre>
 * //
 * // 802.11 data frame with the 8-byte SNAP header (AA AA 03, 00 00 00, <2-byte ~EtherType>)
 * //
 * packet Ieee80211DataFrameWithSNAP extends Ieee80211DataFrame
 * {
 *     byteLength = DATAFRAME_HEADER_MINLENGTH / 8 + SNAP_HEADER_BYTES; // TODO: LLC(SNAP) headers should be in a separate packet
 *     int etherType \@enum(EtherType);
 * }
 * </pre>
 */
class Ieee80211DataFrameWithSNAP : public ::inet::ieee80211::Ieee80211DataFrame
{
  protected:
    int etherType;

  private:
    void copy(const Ieee80211DataFrameWithSNAP& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211DataFrameWithSNAP&);

  public:
    Ieee80211DataFrameWithSNAP(const char *name=nullptr, short kind=0);
    Ieee80211DataFrameWithSNAP(const Ieee80211DataFrameWithSNAP& other);
    virtual ~Ieee80211DataFrameWithSNAP();
    Ieee80211DataFrameWithSNAP& operator=(const Ieee80211DataFrameWithSNAP& other);
    virtual Ieee80211DataFrameWithSNAP *dup() const override {return new Ieee80211DataFrameWithSNAP(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getEtherType() const;
    virtual void setEtherType(int etherType);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211DataFrameWithSNAP& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211DataFrameWithSNAP& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:217</tt> by nedtool.
 * <pre>
 * //
 * // Base class for 802.11 management frames (subclasses will add frame body contents)
 * //
 * packet Ieee80211ManagementFrame extends Ieee80211DataOrMgmtFrame
 * {
 * }
 * </pre>
 */
class Ieee80211ManagementFrame : public ::inet::ieee80211::Ieee80211DataOrMgmtFrame
{
  protected:

  private:
    void copy(const Ieee80211ManagementFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ManagementFrame&);

  public:
    Ieee80211ManagementFrame(const char *name=nullptr, short kind=0);
    Ieee80211ManagementFrame(const Ieee80211ManagementFrame& other);
    virtual ~Ieee80211ManagementFrame();
    Ieee80211ManagementFrame& operator=(const Ieee80211ManagementFrame& other);
    virtual Ieee80211ManagementFrame *dup() const override {return new Ieee80211ManagementFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211ManagementFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211ManagementFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:222</tt> by nedtool.
 * <pre>
 * // 8.3.3.13 Action frame format -- mgmt frame with subtype action
 * packet Ieee80211ActionFrame extends Ieee80211ManagementFrame
 * {
 *     type = ST_ACTION;
 *     short category;
 *     // TODO: subclasses will add action subfield contents
 *     //short action \@enum(WirelessNetworkManagementAction); // action TODO: remove it
 * }
 * </pre>
 */
class Ieee80211ActionFrame : public ::inet::ieee80211::Ieee80211ManagementFrame
{
  protected:
    short category;

  private:
    void copy(const Ieee80211ActionFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211ActionFrame&);

  public:
    Ieee80211ActionFrame(const char *name=nullptr, short kind=0);
    Ieee80211ActionFrame(const Ieee80211ActionFrame& other);
    virtual ~Ieee80211ActionFrame();
    Ieee80211ActionFrame& operator=(const Ieee80211ActionFrame& other);
    virtual Ieee80211ActionFrame *dup() const override {return new Ieee80211ActionFrame(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual short getCategory() const;
    virtual void setCategory(short category);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211ActionFrame& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211ActionFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:230</tt> by nedtool.
 * <pre>
 * packet Ieee80211MsduSubframe
 * {
 *     bitLength = LENGTH_A_MSDU_SUBFRAME_HEADER; // + snap header if necessary
 *     MACAddress sa; // source addr.
 *     MACAddress da; // destination addr.
 *     int length;
 *     int etherType \@enum(EtherType); // TODO: review optional snap header (the standard does not define it: Figure 8-32—A-MSDU subframe structure) 
 * }
 * </pre>
 */
class Ieee80211MsduSubframe : public ::omnetpp::cPacket
{
  protected:
    MACAddress sa;
    MACAddress da;
    int length;
    int etherType;

  private:
    void copy(const Ieee80211MsduSubframe& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211MsduSubframe&);

  public:
    Ieee80211MsduSubframe(const char *name=nullptr, short kind=0);
    Ieee80211MsduSubframe(const Ieee80211MsduSubframe& other);
    virtual ~Ieee80211MsduSubframe();
    Ieee80211MsduSubframe& operator=(const Ieee80211MsduSubframe& other);
    virtual Ieee80211MsduSubframe *dup() const override {return new Ieee80211MsduSubframe(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual MACAddress& getSa();
    virtual const MACAddress& getSa() const {return const_cast<Ieee80211MsduSubframe*>(this)->getSa();}
    virtual void setSa(const MACAddress& sa);
    virtual MACAddress& getDa();
    virtual const MACAddress& getDa() const {return const_cast<Ieee80211MsduSubframe*>(this)->getDa();}
    virtual void setDa(const MACAddress& da);
    virtual int getLength() const;
    virtual void setLength(int length);
    virtual int getEtherType() const;
    virtual void setEtherType(int etherType);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MsduSubframe& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MsduSubframe& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:239</tt> by nedtool.
 * <pre>
 * packet Ieee80211AMsdu
 * {
 *     Ieee80211MsduSubframe subframes[];
 * }
 * </pre>
 */
class Ieee80211AMsdu : public ::omnetpp::cPacket
{
  protected:
    Ieee80211MsduSubframe *subframes; // array ptr
    unsigned int subframes_arraysize;

  private:
    void copy(const Ieee80211AMsdu& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AMsdu&);

  public:
    Ieee80211AMsdu(const char *name=nullptr, short kind=0);
    Ieee80211AMsdu(const Ieee80211AMsdu& other);
    virtual ~Ieee80211AMsdu();
    Ieee80211AMsdu& operator=(const Ieee80211AMsdu& other);
    virtual Ieee80211AMsdu *dup() const override {return new Ieee80211AMsdu(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setSubframesArraySize(unsigned int size);
    virtual unsigned int getSubframesArraySize() const;
    virtual Ieee80211MsduSubframe& getSubframes(unsigned int k);
    virtual const Ieee80211MsduSubframe& getSubframes(unsigned int k) const {return const_cast<Ieee80211AMsdu*>(this)->getSubframes(k);}
    virtual void setSubframes(unsigned int k, const Ieee80211MsduSubframe& subframes);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211AMsdu& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211AMsdu& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:247</tt> by nedtool.
 * <pre>
 * //
 * // Table 8-203—ADDBA Request frame Action field format -- 736p.
 * //
 * packet Ieee80211AddbaRequest extends Ieee80211ActionFrame
 * {
 *     byteLength = LENGTH_ADDBAREQ / 8;
 *     category = 3; // representing Block Ack
 *     int blockAckAction = 0; // representing ADDBA request
 *     int dialogToken = 1; // nonzero, arbitrary
 * 
 *     // Block Ack Parameter Set field
 *     bool aMsduSupported; // The A-MSDU Supported subfield determines whether an A-MSDU may be carried in a QoS data MPDU sent under this Block Ack agreement.
 *     bool blockAckPolicy; // The Block Ack Policy subfield is set to 1 for immediate Block Ack and 0 for delayed Block Ack.
 *     int tid; // The TID subfield contains the value of the TC or TS for which the BlockAck is being requested.
 *     int bufferSize; // The Buffer Size subfield indicates the number of buffers available for this particular TID
 * 
 *     // Block Ack Timeout Value field
 *     // The Block Ack Timeout Value field contains the duration, in TUs, after which the Block Ack setup is
 *     // terminated, if there are no frame exchanges (see 10.5.4) within this duration using this Block Ack
 *     //  agreement. A value of 0 disables the timeout.
 *     simtime_t blockAckTimeoutValue;
 * 
 *     // Block Ack Starting Sequence Control
 *     // The Starting Sequence Number subfield of the Block Ack Starting Sequence Control subfield contains the sequence number of the first MSDU for which this Basic
 *     // BlockAckReq frame is sent. The Fragment Number subfield is set to 0.
 *     int _fragmentNumber = 0; // FIXME: DataOrMgmtFreme has a fragmentNumber
 *     int startingSequenceNumber; // the sequence number of the first MSDU
 * 
 * }
 * </pre>
 */
class Ieee80211AddbaRequest : public ::inet::ieee80211::Ieee80211ActionFrame
{
  protected:
    int blockAckAction;
    int dialogToken;
    bool aMsduSupported;
    bool blockAckPolicy;
    int tid;
    int bufferSize;
    ::omnetpp::simtime_t blockAckTimeoutValue;
    int _fragmentNumber;
    int startingSequenceNumber;

  private:
    void copy(const Ieee80211AddbaRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AddbaRequest&);

  public:
    Ieee80211AddbaRequest(const char *name=nullptr, short kind=0);
    Ieee80211AddbaRequest(const Ieee80211AddbaRequest& other);
    virtual ~Ieee80211AddbaRequest();
    Ieee80211AddbaRequest& operator=(const Ieee80211AddbaRequest& other);
    virtual Ieee80211AddbaRequest *dup() const override {return new Ieee80211AddbaRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getBlockAckAction() const;
    virtual void setBlockAckAction(int blockAckAction);
    virtual int getDialogToken() const;
    virtual void setDialogToken(int dialogToken);
    virtual bool getAMsduSupported() const;
    virtual void setAMsduSupported(bool aMsduSupported);
    virtual bool getBlockAckPolicy() const;
    virtual void setBlockAckPolicy(bool blockAckPolicy);
    virtual int getTid() const;
    virtual void setTid(int tid);
    virtual int getBufferSize() const;
    virtual void setBufferSize(int bufferSize);
    virtual ::omnetpp::simtime_t getBlockAckTimeoutValue() const;
    virtual void setBlockAckTimeoutValue(::omnetpp::simtime_t blockAckTimeoutValue);
    virtual int get_fragmentNumber() const;
    virtual void set_fragmentNumber(int _fragmentNumber);
    virtual int getStartingSequenceNumber() const;
    virtual void setStartingSequenceNumber(int startingSequenceNumber);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211AddbaRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211AddbaRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:274</tt> by nedtool.
 * <pre>
 * packet Ieee80211AddbaResponse extends Ieee80211ActionFrame
 * {
 *     // byteLength TODO
 *     category = 3; // representing Block Ack
 *     int blockAckAction = 1; // representing ADDBA response
 *     int dialogToken = 1; // The Dialog Token field value is copied from the corresponding received ADDBA Request frame.
 *     int statusCode; // The Status Code field is used in a response management frame to indicate the success or failure of a requested operation.
 * 
 *     // Block Ack Parameter Set field
 *     bool aMsduSupported; // The A-MSDU Supported subfield determines whether an A-MSDU may be carried in a QoS data MPDU sent under this Block Ack agreement.
 *     bool blockAckPolicy; // The Block Ack Policy subfield is set to 1 for immediate Block Ack and 0 for delayed Block Ack.
 *     int tid; // The TID subfield contains the value of the TC or TS for which the BlockAck is being requested.
 *     int bufferSize; // The Buffer Size subfield indicates the number of buffers available for this particular TID
 * 
 *     // Block Ack Timeout Value field
 *     // The Block Ack Timeout Value field contains the duration, in TUs, after which the Block Ack setup is
 *     // terminated, if there are no frame exchanges (see 10.5.4) within this duration using this Block Ack
 *     //  agreement. A value of 0 disables the timeout.
 *     simtime_t blockAckTimeoutValue;
 * }
 * </pre>
 */
class Ieee80211AddbaResponse : public ::inet::ieee80211::Ieee80211ActionFrame
{
  protected:
    int blockAckAction;
    int dialogToken;
    int statusCode;
    bool aMsduSupported;
    bool blockAckPolicy;
    int tid;
    int bufferSize;
    ::omnetpp::simtime_t blockAckTimeoutValue;

  private:
    void copy(const Ieee80211AddbaResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211AddbaResponse&);

  public:
    Ieee80211AddbaResponse(const char *name=nullptr, short kind=0);
    Ieee80211AddbaResponse(const Ieee80211AddbaResponse& other);
    virtual ~Ieee80211AddbaResponse();
    Ieee80211AddbaResponse& operator=(const Ieee80211AddbaResponse& other);
    virtual Ieee80211AddbaResponse *dup() const override {return new Ieee80211AddbaResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getBlockAckAction() const;
    virtual void setBlockAckAction(int blockAckAction);
    virtual int getDialogToken() const;
    virtual void setDialogToken(int dialogToken);
    virtual int getStatusCode() const;
    virtual void setStatusCode(int statusCode);
    virtual bool getAMsduSupported() const;
    virtual void setAMsduSupported(bool aMsduSupported);
    virtual bool getBlockAckPolicy() const;
    virtual void setBlockAckPolicy(bool blockAckPolicy);
    virtual int getTid() const;
    virtual void setTid(int tid);
    virtual int getBufferSize() const;
    virtual void setBufferSize(int bufferSize);
    virtual ::omnetpp::simtime_t getBlockAckTimeoutValue() const;
    virtual void setBlockAckTimeoutValue(::omnetpp::simtime_t blockAckTimeoutValue);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211AddbaResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211AddbaResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:298</tt> by nedtool.
 * <pre>
 * //
 * // 8.5.5.4 DELBA frame format
 * //
 * packet Ieee80211Delba extends Ieee80211ActionFrame
 * {
 *     // byteLength TODO
 *     category = 3;
 *     int blockAckAction = 2; // representing DELBA
 * 
 *     // DELBA Parameter Set
 *     // It is set to 1 to indicate the originator and is set to 0 to indicate the recipient.
 *     // The Initiator subfield indicates if the originator or the recipient of the data is sending this frame.
 *     bool initiator;
 * 
 *     // The TID subfield indicates the TSID or the UP for which the Block Ack has been originally set up.
 *     int tid;
 * 
 *     // This Reason Code field is used to indicate the reason that an unsolicited notification management frame of
 *     // type Disassociation, Deauthentication, DELTS, DELBA, DLS Teardown, or Mesh Peering Close was
 *     // generated.
 *     int reasonCode;
 * }
 * </pre>
 */
class Ieee80211Delba : public ::inet::ieee80211::Ieee80211ActionFrame
{
  protected:
    int blockAckAction;
    bool initiator;
    int tid;
    int reasonCode;

  private:
    void copy(const Ieee80211Delba& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211Delba&);

  public:
    Ieee80211Delba(const char *name=nullptr, short kind=0);
    Ieee80211Delba(const Ieee80211Delba& other);
    virtual ~Ieee80211Delba();
    Ieee80211Delba& operator=(const Ieee80211Delba& other);
    virtual Ieee80211Delba *dup() const override {return new Ieee80211Delba(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getBlockAckAction() const;
    virtual void setBlockAckAction(int blockAckAction);
    virtual bool getInitiator() const;
    virtual void setInitiator(bool initiator);
    virtual int getTid() const;
    virtual void setTid(int tid);
    virtual int getReasonCode() const;
    virtual void setReasonCode(int reasonCode);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211Delba& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211Delba& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:323</tt> by nedtool.
 * <pre>
 * //
 * // 8.3.1.8 BlockAckReq frame format
 * //
 * packet Ieee80211BlockAckReq extends Ieee80211TwoAddressFrame
 * {
 *     // byteLength TODO
 *     // The RA field of the BlockAck frame is the address of the recipient STA that requested the Block Ack.
 *     // The TA field is the address of the STA transmitting the BlockAck frame.
 *     type = ST_BLOCKACK_REQ;
 * 
 *     bool multiTid;
 *     bool compressedBitmap;
 *     bool barAckPolicy; // 0-Normal Acknowledgment, 1-No Acknowledgment.
 * }
 * </pre>
 */
class Ieee80211BlockAckReq : public ::inet::ieee80211::Ieee80211TwoAddressFrame
{
  protected:
    bool multiTid;
    bool compressedBitmap;
    bool barAckPolicy;

  private:
    void copy(const Ieee80211BlockAckReq& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211BlockAckReq&);

  public:
    Ieee80211BlockAckReq(const char *name=nullptr, short kind=0);
    Ieee80211BlockAckReq(const Ieee80211BlockAckReq& other);
    virtual ~Ieee80211BlockAckReq();
    Ieee80211BlockAckReq& operator=(const Ieee80211BlockAckReq& other);
    virtual Ieee80211BlockAckReq *dup() const override {return new Ieee80211BlockAckReq(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getMultiTid() const;
    virtual void setMultiTid(bool multiTid);
    virtual bool getCompressedBitmap() const;
    virtual void setCompressedBitmap(bool compressedBitmap);
    virtual bool getBarAckPolicy() const;
    virtual void setBarAckPolicy(bool barAckPolicy);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211BlockAckReq& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211BlockAckReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:335</tt> by nedtool.
 * <pre>
 * packet Ieee80211BasicBlockAckReq extends Ieee80211BlockAckReq
 * {
 *     int tidInfo; //  The TID_INFO subfield of the BAR Control field of the Basic BlockAckReq frame contains the TID for which a Basic BlockAck frame is requested.
 * 
 *     // The BAR Information field of the Basic BlockAckReq frame contains the Block Ack Starting Sequence
 *     // Control subfield, as shown in Figure 8-21. The Starting Sequence Number subfield of the Block Ack
 *     // Starting Sequence Control subfield contains the sequence number of the first MSDU for which this Basic
 *     // BlockAckReq frame is sent. The Fragment Number subfield is set to 0.
 *     int fragmentNumber = 0;
 *     int startingSequenceNumber;
 * 
 *     multiTid = 0;
 *     compressedBitmap = 0;
 * }
 * </pre>
 */
class Ieee80211BasicBlockAckReq : public ::inet::ieee80211::Ieee80211BlockAckReq
{
  protected:
    int tidInfo;
    int fragmentNumber;
    int startingSequenceNumber;

  private:
    void copy(const Ieee80211BasicBlockAckReq& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211BasicBlockAckReq&);

  public:
    Ieee80211BasicBlockAckReq(const char *name=nullptr, short kind=0);
    Ieee80211BasicBlockAckReq(const Ieee80211BasicBlockAckReq& other);
    virtual ~Ieee80211BasicBlockAckReq();
    Ieee80211BasicBlockAckReq& operator=(const Ieee80211BasicBlockAckReq& other);
    virtual Ieee80211BasicBlockAckReq *dup() const override {return new Ieee80211BasicBlockAckReq(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getTidInfo() const;
    virtual void setTidInfo(int tidInfo);
    virtual int getFragmentNumber() const;
    virtual void setFragmentNumber(int fragmentNumber);
    virtual int getStartingSequenceNumber() const;
    virtual void setStartingSequenceNumber(int startingSequenceNumber);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211BasicBlockAckReq& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211BasicBlockAckReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:353</tt> by nedtool.
 * <pre>
 * packet Ieee80211CompressedBlockAckReq extends Ieee80211BlockAckReq
 * {
 *     int tidInfo; // The TID_INFO subfield of the BAR Control field of the Compressed BlockAckReq frame contains the TID for which a BlockAck frame is requested.
 * 
 *     // The RA field of the BlockAck frame is the address of the recipient STA that requested the Block Ack.
 *     // The TA field is the address of the STA transmitting the BlockAck frame.
 *     type = ST_BLOCKACK_REQ;
 *     // The BAR Information field of the Compressed BlockAckReq frame contains the Block Ack Starting
 *     // Sequence Control subfield, as shown in Figure 8-21. The Starting Sequence Number subfield of the Block
 *     // Ack Starting Sequence Control subfield contains the sequence number of the first MSDU or A-MSDU for
 *     // which this BlockAckReq frame is sent. The Fragment Number subfield of the Block Ack Starting Sequence
 *     // Control subfield is set to 0.
 * 
 *     int fragmentNumber = 0;
 *     int startingSequenceNumber;
 * 
 *     multiTid = 0;
 *     compressedBitmap = 1;
 * }
 * </pre>
 */
class Ieee80211CompressedBlockAckReq : public ::inet::ieee80211::Ieee80211BlockAckReq
{
  protected:
    int tidInfo;
    int fragmentNumber;
    int startingSequenceNumber;

  private:
    void copy(const Ieee80211CompressedBlockAckReq& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211CompressedBlockAckReq&);

  public:
    Ieee80211CompressedBlockAckReq(const char *name=nullptr, short kind=0);
    Ieee80211CompressedBlockAckReq(const Ieee80211CompressedBlockAckReq& other);
    virtual ~Ieee80211CompressedBlockAckReq();
    Ieee80211CompressedBlockAckReq& operator=(const Ieee80211CompressedBlockAckReq& other);
    virtual Ieee80211CompressedBlockAckReq *dup() const override {return new Ieee80211CompressedBlockAckReq(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getTidInfo() const;
    virtual void setTidInfo(int tidInfo);
    virtual int getFragmentNumber() const;
    virtual void setFragmentNumber(int fragmentNumber);
    virtual int getStartingSequenceNumber() const;
    virtual void setStartingSequenceNumber(int startingSequenceNumber);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211CompressedBlockAckReq& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211CompressedBlockAckReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:375</tt> by nedtool.
 * <pre>
 * packet Ieee80211MultiTidBlockAckReq extends Ieee80211BlockAckReq
 * {
 *     // byteLength TODO
 *     // The RA field of the BlockAck frame is the address of the recipient STA that requested the Block Ack.
 *     // The TA field is the address of the STA transmitting the BlockAck frame.
 *     type = ST_BLOCKACK_REQ;
 *     // The BAR Information field of the Compressed BlockAckReq frame contains the Block Ack Starting
 *     // Sequence Control subfield, as shown in Figure 8-21. The Starting Sequence Number subfield of the Block
 *     // Ack Starting Sequence Control subfield contains the sequence number of the first MSDU or A-MSDU for
 *     // which this BlockAckReq frame is sent. The Fragment Number subfield of the Block Ack Starting Sequence
 *     // Control subfield is set to 0.
 * 
 *     multiTid = 1;
 *     compressedBitmap = 1;
 * 
 *     // TODO: unimplemented
 * }
 * </pre>
 */
class Ieee80211MultiTidBlockAckReq : public ::inet::ieee80211::Ieee80211BlockAckReq
{
  protected:

  private:
    void copy(const Ieee80211MultiTidBlockAckReq& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211MultiTidBlockAckReq&);

  public:
    Ieee80211MultiTidBlockAckReq(const char *name=nullptr, short kind=0);
    Ieee80211MultiTidBlockAckReq(const Ieee80211MultiTidBlockAckReq& other);
    virtual ~Ieee80211MultiTidBlockAckReq();
    Ieee80211MultiTidBlockAckReq& operator=(const Ieee80211MultiTidBlockAckReq& other);
    virtual Ieee80211MultiTidBlockAckReq *dup() const override {return new Ieee80211MultiTidBlockAckReq(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MultiTidBlockAckReq& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MultiTidBlockAckReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:397</tt> by nedtool.
 * <pre>
 * //
 * // 8.3.1.9 BlockAck frame format -- 410p.
 * //
 * packet Ieee80211BlockAck extends Ieee80211TwoAddressFrame
 * {
 *     // byteLength TODO
 *     // The RA field of the BlockAck frame is the address of the recipient STA that requested the Block Ack.
 *     // The TA field is the address of the STA transmitting the BlockAck frame.
 *     type = ST_BLOCKACK;
 * 
 *     // BA Control
 *     bool blockAckPolicy; // Table 8-17—BA Ack Policy subfield: 0-Normal Acknowledgment, 1-No Acknowledgment.
 * 
 *     // Table 8-18—BlockAck frame variant encoding
 *     bool multiTid;
 *     bool compressedBitmap;
 * }
 * </pre>
 */
class Ieee80211BlockAck : public ::inet::ieee80211::Ieee80211TwoAddressFrame
{
  protected:
    bool blockAckPolicy;
    bool multiTid;
    bool compressedBitmap;

  private:
    void copy(const Ieee80211BlockAck& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211BlockAck&);

  public:
    Ieee80211BlockAck(const char *name=nullptr, short kind=0);
    Ieee80211BlockAck(const Ieee80211BlockAck& other);
    virtual ~Ieee80211BlockAck();
    Ieee80211BlockAck& operator=(const Ieee80211BlockAck& other);
    virtual Ieee80211BlockAck *dup() const override {return new Ieee80211BlockAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getBlockAckPolicy() const;
    virtual void setBlockAckPolicy(bool blockAckPolicy);
    virtual bool getMultiTid() const;
    virtual void setMultiTid(bool multiTid);
    virtual bool getCompressedBitmap() const;
    virtual void setCompressedBitmap(bool compressedBitmap);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211BlockAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211BlockAck& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:415</tt> by nedtool.
 * <pre>
 * //
 * // 8.3.1.9.2 Basic BlockAck variant -- 411p.
 * //
 * packet Ieee80211BasicBlockAck extends Ieee80211BlockAck
 * {
 *     // byteLength TODO
 *     multiTid = 0;
 *     compressedBitmap = 0;
 * 
 *     // The BA Information field of the Basic BlockAck frame comprises the Block Ack Starting Sequence Control
 *     // subfield and the Block Ack Bitmap subfield, as shown in Figure 8-26.
 * 
 *     int fragmentNumber = 0; // ??
 *     int startingSequenceNumber;
 *     // The Block Ack Bitmap subfield is 128 octets in length and is used to indicate the received status of up to
 *     // 64 MSDUs. Bit position n of the Block Ack bitmap, if equal to 1, acknowledges receipt of an MPDU with an
 *     // MPDU sequence control value equal to (Block Ack Starting Sequence Control + n). Bit position n of the
 *     // Block Ack bitmap, if equal to 0, indicates that an MPDU with MPDU sequence control value equal to
 *     // (Block Ack Starting Sequence Control + n) has not been received. Each of the MPDU Sequence Control
 *     // field and Block Ack Starting Sequence Control subfield values are treated as a 16-bit unsigned integer. For
 *     // unused fragment numbers of an MSDU, the corresponding bits in the bitmap are set to 0.
 *     BitVector blockAckBitmap[64]; // 64 * 16 bitmatrix
 * 
 *     // The TID_INFO subfield of the BA Control field of the Basic BlockAck frame contains the TID for which
 *     // this BlockAck frame is sent.
 *     int tidInfo;
 * }
 * </pre>
 */
class Ieee80211BasicBlockAck : public ::inet::ieee80211::Ieee80211BlockAck
{
  protected:
    int fragmentNumber;
    int startingSequenceNumber;
    BitVector blockAckBitmap[64];
    int tidInfo;

  private:
    void copy(const Ieee80211BasicBlockAck& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211BasicBlockAck&);

  public:
    Ieee80211BasicBlockAck(const char *name=nullptr, short kind=0);
    Ieee80211BasicBlockAck(const Ieee80211BasicBlockAck& other);
    virtual ~Ieee80211BasicBlockAck();
    Ieee80211BasicBlockAck& operator=(const Ieee80211BasicBlockAck& other);
    virtual Ieee80211BasicBlockAck *dup() const override {return new Ieee80211BasicBlockAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getFragmentNumber() const;
    virtual void setFragmentNumber(int fragmentNumber);
    virtual int getStartingSequenceNumber() const;
    virtual void setStartingSequenceNumber(int startingSequenceNumber);
    virtual unsigned int getBlockAckBitmapArraySize() const;
    virtual BitVector& getBlockAckBitmap(unsigned int k);
    virtual const BitVector& getBlockAckBitmap(unsigned int k) const {return const_cast<Ieee80211BasicBlockAck*>(this)->getBlockAckBitmap(k);}
    virtual void setBlockAckBitmap(unsigned int k, const BitVector& blockAckBitmap);
    virtual int getTidInfo() const;
    virtual void setTidInfo(int tidInfo);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211BasicBlockAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211BasicBlockAck& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:443</tt> by nedtool.
 * <pre>
 * //
 * // 8.3.1.9.3 Compressed BlockAck variant
 * //
 * packet Ieee80211CompressedBlockAck extends Ieee80211BlockAck
 * {
 *     // byteLength TODO
 *     multiTid = 0;
 *     compressedBitmap = 1;
 * 
 *     // The BA Information field of the Compressed BlockAck frame comprises the Block Ack Starting Sequence
 *     // Control subfield and the Block Ack Bitmap subfield, as shown in Figure 8-27.
 * 
 *     int fragmentNumber = 0;
 *     int startingSequenceNumber;
 *     BitVector blockAckBitmap; // 64 bits
 * 
 *     // The TID_INFO subfield of the BA Control field of the Compressed BlockAck frame contains the TID for
 *     // which this BlockAck frame is sent.
 *     int tidInfo;
 * }
 * </pre>
 */
class Ieee80211CompressedBlockAck : public ::inet::ieee80211::Ieee80211BlockAck
{
  protected:
    int fragmentNumber;
    int startingSequenceNumber;
    BitVector blockAckBitmap;
    int tidInfo;

  private:
    void copy(const Ieee80211CompressedBlockAck& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211CompressedBlockAck&);

  public:
    Ieee80211CompressedBlockAck(const char *name=nullptr, short kind=0);
    Ieee80211CompressedBlockAck(const Ieee80211CompressedBlockAck& other);
    virtual ~Ieee80211CompressedBlockAck();
    Ieee80211CompressedBlockAck& operator=(const Ieee80211CompressedBlockAck& other);
    virtual Ieee80211CompressedBlockAck *dup() const override {return new Ieee80211CompressedBlockAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getFragmentNumber() const;
    virtual void setFragmentNumber(int fragmentNumber);
    virtual int getStartingSequenceNumber() const;
    virtual void setStartingSequenceNumber(int startingSequenceNumber);
    virtual BitVector& getBlockAckBitmap();
    virtual const BitVector& getBlockAckBitmap() const {return const_cast<Ieee80211CompressedBlockAck*>(this)->getBlockAckBitmap();}
    virtual void setBlockAckBitmap(const BitVector& blockAckBitmap);
    virtual int getTidInfo() const;
    virtual void setTidInfo(int tidInfo);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211CompressedBlockAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211CompressedBlockAck& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/linklayer/ieee80211/mac/Ieee80211Frame.msg:464</tt> by nedtool.
 * <pre>
 * //
 * // 8.3.1.9.4 Multi-TID BlockAck variant
 * //
 * packet Ieee80211MultiTidBlockAck extends Ieee80211BlockAck
 * {
 *     // byteLength TODO
 *     multiTid = 1;
 *     compressedBitmap = 1;
 * 
 *     // TODO: unimplemented
 * }
 * </pre>
 */
class Ieee80211MultiTidBlockAck : public ::inet::ieee80211::Ieee80211BlockAck
{
  protected:

  private:
    void copy(const Ieee80211MultiTidBlockAck& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ieee80211MultiTidBlockAck&);

  public:
    Ieee80211MultiTidBlockAck(const char *name=nullptr, short kind=0);
    Ieee80211MultiTidBlockAck(const Ieee80211MultiTidBlockAck& other);
    virtual ~Ieee80211MultiTidBlockAck();
    Ieee80211MultiTidBlockAck& operator=(const Ieee80211MultiTidBlockAck& other);
    virtual Ieee80211MultiTidBlockAck *dup() const override {return new Ieee80211MultiTidBlockAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Ieee80211MultiTidBlockAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Ieee80211MultiTidBlockAck& obj) {obj.parsimUnpack(b);}

} // namespace ieee80211
} // namespace inet

#endif // ifndef __INET__IEEE80211_IEEE80211FRAME_M_H

