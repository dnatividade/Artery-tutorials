//
// Generated file, do not edit! Created by nedtool 5.7 from /home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg.
//

#ifndef __INET_UDPCONTROLINFO_M_H
#define __INET_UDPCONTROLINFO_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0507
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include "inet/networklayer/common/L3Address.h"
// }}


namespace inet {

/**
 * Enum generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:36</tt> by nedtool.
 * <pre>
 * //
 * // UDP command codes, sent by the application to ~UDP. These constants
 * // should be set as message kind on messages sent to the ~UDP entity.
 * //
 * // \@see ~UDPControlInfo, ~UDPStatusInd, ~UDP
 * //
 * enum UDPCommandCode
 * {
 *     UDP_C_DATA = 0;      // send()/sendTo(); see ~UDPSendCommand
 *     UDP_C_BIND = 1;      // bind(); see ~UDPBindCommand
 *     UDP_C_CONNECT = 2;   // connect(); see ~UDPConnectCommand
 *     UDP_C_SETOPTION = 3; // setsockopt(); see ~UDPSetTimeToLiveCommand,...
 *     UDP_C_CLOSE = 4;     // close(); see ~UDPCloseCommand
 * }
 * </pre>
 */
enum UDPCommandCode {
    UDP_C_DATA = 0,
    UDP_C_BIND = 1,
    UDP_C_CONNECT = 2,
    UDP_C_SETOPTION = 3,
    UDP_C_CLOSE = 4
};

/**
 * Enum generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:52</tt> by nedtool.
 * <pre>
 * //
 * // UDP indications, sent by ~UDP to the application. ~UDP will set these
 * // constants as message kind on messages it sends to the application.
 * //
 * // \@see ~UDPControlInfo, ~UDPCommandCode, ~UDP
 * //
 * enum UDPStatusInd
 * {
 *     UDP_I_DATA = 0;  // ~UDP attaches ~UDPIndication to received data packet
 *     UDP_I_ERROR = 1; // ~UDP attaches ~UDPIndication to received data packet
 * }
 * </pre>
 */
enum UDPStatusInd {
    UDP_I_DATA = 0,
    UDP_I_ERROR = 1
};

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:68</tt> by nedtool.
 * <pre>
 * //
 * // Base class for UDP control info classes. The most convenient way to handle
 * // ~UDP is the UDPSocket class, which hides control info from you.
 * //
 * // sockId must uniquely identify the socket in the ~UDP module; the best way
 * // to achieve that is to obtain the value from UDPSocket::generateSocketId().
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPControlInfo
 * {
 *     int sockId = -1;  // must uniquely identify the socket in the ~UDP module
 * }
 * </pre>
 */
class UDPControlInfo : public ::omnetpp::cObject
{
  protected:
    int sockId;

  private:
    void copy(const UDPControlInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPControlInfo&);

  public:
    UDPControlInfo();
    UDPControlInfo(const UDPControlInfo& other);
    virtual ~UDPControlInfo();
    UDPControlInfo& operator=(const UDPControlInfo& other);
    virtual UDPControlInfo *dup() const override {return new UDPControlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getSockId() const;
    virtual void setSockId(int sockId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPControlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPControlInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:83</tt> by nedtool.
 * <pre>
 * //
 * // Control info for binding an UDP socket. To create and bind a socket,
 * // send a message to the ~UDP module with kind=UDP_C_BIND and an
 * // ~UDPBindCommand attached.
 * //
 * // Both the address and the port may be left unset. If the port is
 * // unset, ~UDP will assign an ephemeral port.
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPBindCommand extends UDPControlInfo
 * {
 *     L3Address localAddr;
 *     int localPort = -1;
 * }
 * </pre>
 */
class UDPBindCommand : public ::inet::UDPControlInfo
{
  protected:
    L3Address localAddr;
    int localPort;

  private:
    void copy(const UDPBindCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPBindCommand&);

  public:
    UDPBindCommand();
    UDPBindCommand(const UDPBindCommand& other);
    virtual ~UDPBindCommand();
    UDPBindCommand& operator=(const UDPBindCommand& other);
    virtual UDPBindCommand *dup() const override {return new UDPBindCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual L3Address& getLocalAddr();
    virtual const L3Address& getLocalAddr() const {return const_cast<UDPBindCommand*>(this)->getLocalAddr();}
    virtual void setLocalAddr(const L3Address& localAddr);
    virtual int getLocalPort() const;
    virtual void setLocalPort(int localPort);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPBindCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPBindCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:99</tt> by nedtool.
 * <pre>
 * //
 * // Control info for connecting an UDP socket. To connect a socket,
 * // send a message to the ~UDP module with kind=UDP_C_CONNECT and an
 * // ~UDPConnectCommand attached. If the socket does not exist,
 * // it will be created.
 * //
 * // Both the address and the port must be filled in.
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPConnectCommand extends UDPControlInfo
 * {
 *     L3Address remoteAddr;
 *     int remotePort = -1;
 * }
 * </pre>
 */
class UDPConnectCommand : public ::inet::UDPControlInfo
{
  protected:
    L3Address remoteAddr;
    int remotePort;

  private:
    void copy(const UDPConnectCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPConnectCommand&);

  public:
    UDPConnectCommand();
    UDPConnectCommand(const UDPConnectCommand& other);
    virtual ~UDPConnectCommand();
    UDPConnectCommand& operator=(const UDPConnectCommand& other);
    virtual UDPConnectCommand *dup() const override {return new UDPConnectCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual L3Address& getRemoteAddr();
    virtual const L3Address& getRemoteAddr() const {return const_cast<UDPConnectCommand*>(this)->getRemoteAddr();}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual int getRemotePort() const;
    virtual void setRemotePort(int remotePort);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPConnectCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPConnectCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:116</tt> by nedtool.
 * <pre>
 * //
 * // Control info for sending data via UDP. To send a packet, send it to
 * // the ~UDP module with kind=UDP_C_SEND and an ~UDPSendCommand attached.
 * //
 * // UDP_C_SEND/~UDPSendCommand models both the Unix send() and sendto() calls.
 * // If the socket is connected, destAddr/destPort may be left blank (send()),
 * // otherwise it must contain the destination for the packet (sendto()).
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPSendCommand extends UDPControlInfo
 * {
 *     L3Address destAddr; // destination IPv4 or IPv6 address
 *     int destPort = -1;     // destination port
 *     L3Address srcAddr;       // source address
 *     int interfaceId = -1; // interface on which the packet must be sent (see ~InterfaceTable)
 * }
 * </pre>
 */
class UDPSendCommand : public ::inet::UDPControlInfo
{
  protected:
    L3Address destAddr;
    int destPort;
    L3Address srcAddr;
    int interfaceId;

  private:
    void copy(const UDPSendCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSendCommand&);

  public:
    UDPSendCommand();
    UDPSendCommand(const UDPSendCommand& other);
    virtual ~UDPSendCommand();
    UDPSendCommand& operator=(const UDPSendCommand& other);
    virtual UDPSendCommand *dup() const override {return new UDPSendCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual L3Address& getDestAddr();
    virtual const L3Address& getDestAddr() const {return const_cast<UDPSendCommand*>(this)->getDestAddr();}
    virtual void setDestAddr(const L3Address& destAddr);
    virtual int getDestPort() const;
    virtual void setDestPort(int destPort);
    virtual L3Address& getSrcAddr();
    virtual const L3Address& getSrcAddr() const {return const_cast<UDPSendCommand*>(this)->getSrcAddr();}
    virtual void setSrcAddr(const L3Address& srcAddr);
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPSendCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPSendCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:131</tt> by nedtool.
 * <pre>
 * //
 * // Control info for closing an UDP socket. To close a socket, send a message
 * // to the ~UDP module with kind=UDP_C_CLOSE and an ~UDPCloseCommand attached.
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPCloseCommand extends UDPControlInfo
 * {
 * }
 * </pre>
 */
class UDPCloseCommand : public ::inet::UDPControlInfo
{
  protected:

  private:
    void copy(const UDPCloseCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPCloseCommand&);

  public:
    UDPCloseCommand();
    UDPCloseCommand(const UDPCloseCommand& other);
    virtual ~UDPCloseCommand();
    UDPCloseCommand& operator=(const UDPCloseCommand& other);
    virtual UDPCloseCommand *dup() const override {return new UDPCloseCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPCloseCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPCloseCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:142</tt> by nedtool.
 * <pre>
 * //
 * // Control info that is attached to received data packets, sent up from the
 * // ~UDP module to the application with UDP_I_DATA as message kind.
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPDataIndication extends UDPControlInfo
 * {
 *     L3Address srcAddr;   // source IPv4 or IPv6 address of the received packet
 *     L3Address destAddr;  // destination IPv4 or IPv6 address of the received packet
 *     int srcPort;           // source port of the received packet
 *     int destPort;          // destination port of the received packet
 *     int ttl;               // TTL field of the received packet
 *     int interfaceId;       // interface on which the packet was received (see ~InterfaceTable)
 *     unsigned char typeOfService; // IPv4 Type of Service / IPv6 Traffic Class field of received packet
 * }
 * </pre>
 */
class UDPDataIndication : public ::inet::UDPControlInfo
{
  protected:
    L3Address srcAddr;
    L3Address destAddr;
    int srcPort;
    int destPort;
    int ttl;
    int interfaceId;
    unsigned char typeOfService;

  private:
    void copy(const UDPDataIndication& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPDataIndication&);

  public:
    UDPDataIndication();
    UDPDataIndication(const UDPDataIndication& other);
    virtual ~UDPDataIndication();
    UDPDataIndication& operator=(const UDPDataIndication& other);
    virtual UDPDataIndication *dup() const override {return new UDPDataIndication(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual L3Address& getSrcAddr();
    virtual const L3Address& getSrcAddr() const {return const_cast<UDPDataIndication*>(this)->getSrcAddr();}
    virtual void setSrcAddr(const L3Address& srcAddr);
    virtual L3Address& getDestAddr();
    virtual const L3Address& getDestAddr() const {return const_cast<UDPDataIndication*>(this)->getDestAddr();}
    virtual void setDestAddr(const L3Address& destAddr);
    virtual int getSrcPort() const;
    virtual void setSrcPort(int srcPort);
    virtual int getDestPort() const;
    virtual void setDestPort(int destPort);
    virtual int getTtl() const;
    virtual void setTtl(int ttl);
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
    virtual unsigned char getTypeOfService() const;
    virtual void setTypeOfService(unsigned char typeOfService);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPDataIndication& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPDataIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:160</tt> by nedtool.
 * <pre>
 * //
 * // Control info that is sent up from the ~UDP module to the application with
 * // UDP_I_ERROR as message kind when ~UDP receives an ICMP error for a packet
 * // previously sent from the socket.
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPErrorIndication extends UDPControlInfo
 * {
 *     L3Address srcAddr;   // source IPv4 or IPv6 address of the undeliverable packet
 *     L3Address destAddr;  // destination IPv4 or IPv6 address of the undeliverable packet
 *     int srcPort;           // source port of the undeliverable packet
 *     int destPort;          // destination port of the undeliverable packet
 * }
 * </pre>
 */
class UDPErrorIndication : public ::inet::UDPControlInfo
{
  protected:
    L3Address srcAddr;
    L3Address destAddr;
    int srcPort;
    int destPort;

  private:
    void copy(const UDPErrorIndication& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPErrorIndication&);

  public:
    UDPErrorIndication();
    UDPErrorIndication(const UDPErrorIndication& other);
    virtual ~UDPErrorIndication();
    UDPErrorIndication& operator=(const UDPErrorIndication& other);
    virtual UDPErrorIndication *dup() const override {return new UDPErrorIndication(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual L3Address& getSrcAddr();
    virtual const L3Address& getSrcAddr() const {return const_cast<UDPErrorIndication*>(this)->getSrcAddr();}
    virtual void setSrcAddr(const L3Address& srcAddr);
    virtual L3Address& getDestAddr();
    virtual const L3Address& getDestAddr() const {return const_cast<UDPErrorIndication*>(this)->getDestAddr();}
    virtual void setDestAddr(const L3Address& destAddr);
    virtual int getSrcPort() const;
    virtual void setSrcPort(int srcPort);
    virtual int getDestPort() const;
    virtual void setDestPort(int destPort);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPErrorIndication& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPErrorIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:171</tt> by nedtool.
 * <pre>
 * //
 * // Base class for UDP socket option control info classes.
 * //
 * class UDPSetOptionCommand extends UDPControlInfo
 * {
 * }
 * </pre>
 */
class UDPSetOptionCommand : public ::inet::UDPControlInfo
{
  protected:

  private:
    void copy(const UDPSetOptionCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetOptionCommand&);

  public:
    UDPSetOptionCommand();
    UDPSetOptionCommand(const UDPSetOptionCommand& other);
    virtual ~UDPSetOptionCommand();
    UDPSetOptionCommand& operator=(const UDPSetOptionCommand& other);
    virtual UDPSetOptionCommand *dup() const override {return new UDPSetOptionCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPSetOptionCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPSetOptionCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:183</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the Time To Live (a.k.a. Hop Limit) option on an
 * // UDP socket. This option will affect both multicast and unicast packets.
 * // To set the option, send a message to the ~UDP module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPSetTimeToLiveCommand extends UDPSetOptionCommand
 * {
 *     int ttl;
 * }
 * </pre>
 */
class UDPSetTimeToLiveCommand : public ::inet::UDPSetOptionCommand
{
  protected:
    int ttl;

  private:
    void copy(const UDPSetTimeToLiveCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetTimeToLiveCommand&);

  public:
    UDPSetTimeToLiveCommand();
    UDPSetTimeToLiveCommand(const UDPSetTimeToLiveCommand& other);
    virtual ~UDPSetTimeToLiveCommand();
    UDPSetTimeToLiveCommand& operator=(const UDPSetTimeToLiveCommand& other);
    virtual UDPSetTimeToLiveCommand *dup() const override {return new UDPSetTimeToLiveCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getTtl() const;
    virtual void setTtl(int ttl);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPSetTimeToLiveCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPSetTimeToLiveCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:198</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the Type of Service (IPv4) or Traffic Class (IPv6)
 * // header field on outgoing IPv4/IPv6 packets sent from an UDP socket.
 * // This is an 8-bit field, the lowest 6 bits are the DSCP (DiffServ Code Point)
 * // and the highest 2 bits are the ECN (Explicit Congestion Notification).
 * // To set the option, send a message to  the ~UDP module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPSetTypeOfServiceCommand extends UDPSetOptionCommand
 * {
 *     char tos;  // ToS byte for IPv4/IPv6
 * }
 * </pre>
 */
class UDPSetTypeOfServiceCommand : public ::inet::UDPSetOptionCommand
{
  protected:
    char tos;

  private:
    void copy(const UDPSetTypeOfServiceCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetTypeOfServiceCommand&);

  public:
    UDPSetTypeOfServiceCommand();
    UDPSetTypeOfServiceCommand(const UDPSetTypeOfServiceCommand& other);
    virtual ~UDPSetTypeOfServiceCommand();
    UDPSetTypeOfServiceCommand& operator=(const UDPSetTypeOfServiceCommand& other);
    virtual UDPSetTypeOfServiceCommand *dup() const override {return new UDPSetTypeOfServiceCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual char getTos() const;
    virtual void setTos(char tos);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPSetTypeOfServiceCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPSetTypeOfServiceCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:210</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the Broadcast option on an UDP socket.
 * // To set the option, send a message to the ~UDP module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPSetBroadcastCommand extends UDPSetOptionCommand
 * {
 *     bool broadcast;
 * }
 * </pre>
 */
class UDPSetBroadcastCommand : public ::inet::UDPSetOptionCommand
{
  protected:
    bool broadcast;

  private:
    void copy(const UDPSetBroadcastCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetBroadcastCommand&);

  public:
    UDPSetBroadcastCommand();
    UDPSetBroadcastCommand(const UDPSetBroadcastCommand& other);
    virtual ~UDPSetBroadcastCommand();
    UDPSetBroadcastCommand& operator=(const UDPSetBroadcastCommand& other);
    virtual UDPSetBroadcastCommand *dup() const override {return new UDPSetBroadcastCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getBroadcast() const;
    virtual void setBroadcast(bool broadcast);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPSetBroadcastCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPSetBroadcastCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:222</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the multicast output interface for an UDP socket.
 * // To set the option, send a message to the ~UDP module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPSetMulticastInterfaceCommand extends UDPSetOptionCommand
 * {
 *     int interfaceId;
 * }
 * </pre>
 */
class UDPSetMulticastInterfaceCommand : public ::inet::UDPSetOptionCommand
{
  protected:
    int interfaceId;

  private:
    void copy(const UDPSetMulticastInterfaceCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetMulticastInterfaceCommand&);

  public:
    UDPSetMulticastInterfaceCommand();
    UDPSetMulticastInterfaceCommand(const UDPSetMulticastInterfaceCommand& other);
    virtual ~UDPSetMulticastInterfaceCommand();
    UDPSetMulticastInterfaceCommand& operator=(const UDPSetMulticastInterfaceCommand& other);
    virtual UDPSetMulticastInterfaceCommand *dup() const override {return new UDPSetMulticastInterfaceCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPSetMulticastInterfaceCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPSetMulticastInterfaceCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:236</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the multicast loop option for an UDP socket.
 * // When the option is true, a copy of the outgoing multicast packet
 * // is delivered locally via the loopback interface.
 * // To set the option, send a message to the ~UDP module with kind=UDP_C_SETOPTION
 * // and an instance of this control info class attached.
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPSetMulticastLoopCommand extends UDPSetOptionCommand
 * {
 *     bool loop;
 * }
 * </pre>
 */
class UDPSetMulticastLoopCommand : public ::inet::UDPSetOptionCommand
{
  protected:
    bool loop;

  private:
    void copy(const UDPSetMulticastLoopCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetMulticastLoopCommand&);

  public:
    UDPSetMulticastLoopCommand();
    UDPSetMulticastLoopCommand(const UDPSetMulticastLoopCommand& other);
    virtual ~UDPSetMulticastLoopCommand();
    UDPSetMulticastLoopCommand& operator=(const UDPSetMulticastLoopCommand& other);
    virtual UDPSetMulticastLoopCommand *dup() const override {return new UDPSetMulticastLoopCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getLoop() const;
    virtual void setLoop(bool loop);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPSetMulticastLoopCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPSetMulticastLoopCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:250</tt> by nedtool.
 * <pre>
 * //
 * // Control info for setting the ReuseAddress option on an UDP socket.
 * // When the option is true, then the socket is allowed to bind to an already bound
 * // local address.
 * // To set the option, send a message to the ~UDP module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPSetReuseAddressCommand extends UDPSetOptionCommand
 * {
 *     bool reuseAddress;
 * }
 * </pre>
 */
class UDPSetReuseAddressCommand : public ::inet::UDPSetOptionCommand
{
  protected:
    bool reuseAddress;

  private:
    void copy(const UDPSetReuseAddressCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetReuseAddressCommand&);

  public:
    UDPSetReuseAddressCommand();
    UDPSetReuseAddressCommand(const UDPSetReuseAddressCommand& other);
    virtual ~UDPSetReuseAddressCommand();
    UDPSetReuseAddressCommand& operator=(const UDPSetReuseAddressCommand& other);
    virtual UDPSetReuseAddressCommand *dup() const override {return new UDPSetReuseAddressCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getReuseAddress() const;
    virtual void setReuseAddress(bool reuseAddress);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPSetReuseAddressCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPSetReuseAddressCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:266</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket join multicast groups.
 * // To set the option, send a message to the ~UDP module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // The address-interfaceId pairs are passed as two separate arrays.
 * // When there are less interfaceIds than multicast addresses,
 * // then -1 is assumed (meaning join on all interfaces).
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPJoinMulticastGroupsCommand extends UDPSetOptionCommand
 * {
 *     L3Address multicastAddr[];
 *     int interfaceId[];
 * }
 * </pre>
 */
class UDPJoinMulticastGroupsCommand : public ::inet::UDPSetOptionCommand
{
  protected:
    L3Address *multicastAddr; // array ptr
    unsigned int multicastAddr_arraysize;
    int *interfaceId; // array ptr
    unsigned int interfaceId_arraysize;

  private:
    void copy(const UDPJoinMulticastGroupsCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPJoinMulticastGroupsCommand&);

  public:
    UDPJoinMulticastGroupsCommand();
    UDPJoinMulticastGroupsCommand(const UDPJoinMulticastGroupsCommand& other);
    virtual ~UDPJoinMulticastGroupsCommand();
    UDPJoinMulticastGroupsCommand& operator=(const UDPJoinMulticastGroupsCommand& other);
    virtual UDPJoinMulticastGroupsCommand *dup() const override {return new UDPJoinMulticastGroupsCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setMulticastAddrArraySize(unsigned int size);
    virtual unsigned int getMulticastAddrArraySize() const;
    virtual L3Address& getMulticastAddr(unsigned int k);
    virtual const L3Address& getMulticastAddr(unsigned int k) const {return const_cast<UDPJoinMulticastGroupsCommand*>(this)->getMulticastAddr(k);}
    virtual void setMulticastAddr(unsigned int k, const L3Address& multicastAddr);
    virtual void setInterfaceIdArraySize(unsigned int size);
    virtual unsigned int getInterfaceIdArraySize() const;
    virtual int getInterfaceId(unsigned int k) const;
    virtual void setInterfaceId(unsigned int k, int interfaceId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPJoinMulticastGroupsCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPJoinMulticastGroupsCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:279</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket leave multicast groups.
 * // To set the option, send a message to the ~UDP module with kind=UDP_C_SETOPTION
 * // and an and instance of this control info class attached.
 * //
 * // \@see ~UDPCommandCode
 * //
 * class UDPLeaveMulticastGroupsCommand extends UDPSetOptionCommand
 * {
 *     L3Address multicastAddr[];
 * }
 * </pre>
 */
class UDPLeaveMulticastGroupsCommand : public ::inet::UDPSetOptionCommand
{
  protected:
    L3Address *multicastAddr; // array ptr
    unsigned int multicastAddr_arraysize;

  private:
    void copy(const UDPLeaveMulticastGroupsCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPLeaveMulticastGroupsCommand&);

  public:
    UDPLeaveMulticastGroupsCommand();
    UDPLeaveMulticastGroupsCommand(const UDPLeaveMulticastGroupsCommand& other);
    virtual ~UDPLeaveMulticastGroupsCommand();
    UDPLeaveMulticastGroupsCommand& operator=(const UDPLeaveMulticastGroupsCommand& other);
    virtual UDPLeaveMulticastGroupsCommand *dup() const override {return new UDPLeaveMulticastGroupsCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setMulticastAddrArraySize(unsigned int size);
    virtual unsigned int getMulticastAddrArraySize() const;
    virtual L3Address& getMulticastAddr(unsigned int k);
    virtual const L3Address& getMulticastAddr(unsigned int k) const {return const_cast<UDPLeaveMulticastGroupsCommand*>(this)->getMulticastAddr(k);}
    virtual void setMulticastAddr(unsigned int k, const L3Address& multicastAddr);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPLeaveMulticastGroupsCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPLeaveMulticastGroupsCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:289</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to block multicast traffic from
 * // specific sources after joining a multicast group.
 * //
 * // see IP_BLOCK_SOURCE socket option
 * class UDPBlockMulticastSourcesCommand extends UDPSetOptionCommand
 * {
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class UDPBlockMulticastSourcesCommand : public ::inet::UDPSetOptionCommand
{
  protected:
    int interfaceId;
    L3Address multicastAddr;
    L3Address *sourceList; // array ptr
    unsigned int sourceList_arraysize;

  private:
    void copy(const UDPBlockMulticastSourcesCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPBlockMulticastSourcesCommand&);

  public:
    UDPBlockMulticastSourcesCommand();
    UDPBlockMulticastSourcesCommand(const UDPBlockMulticastSourcesCommand& other);
    virtual ~UDPBlockMulticastSourcesCommand();
    UDPBlockMulticastSourcesCommand& operator=(const UDPBlockMulticastSourcesCommand& other);
    virtual UDPBlockMulticastSourcesCommand *dup() const override {return new UDPBlockMulticastSourcesCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
    virtual L3Address& getMulticastAddr();
    virtual const L3Address& getMulticastAddr() const {return const_cast<UDPBlockMulticastSourcesCommand*>(this)->getMulticastAddr();}
    virtual void setMulticastAddr(const L3Address& multicastAddr);
    virtual void setSourceListArraySize(unsigned int size);
    virtual unsigned int getSourceListArraySize() const;
    virtual L3Address& getSourceList(unsigned int k);
    virtual const L3Address& getSourceList(unsigned int k) const {return const_cast<UDPBlockMulticastSourcesCommand*>(this)->getSourceList(k);}
    virtual void setSourceList(unsigned int k, const L3Address& sourceList);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPBlockMulticastSourcesCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPBlockMulticastSourcesCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:301</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to permit multicast traffic from
 * // a previously blocked source.
 * //
 * // see IP_UNBLOCK_SOURCE socket option
 * class UDPUnblockMulticastSourcesCommand extends UDPSetOptionCommand
 * {
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class UDPUnblockMulticastSourcesCommand : public ::inet::UDPSetOptionCommand
{
  protected:
    int interfaceId;
    L3Address multicastAddr;
    L3Address *sourceList; // array ptr
    unsigned int sourceList_arraysize;

  private:
    void copy(const UDPUnblockMulticastSourcesCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPUnblockMulticastSourcesCommand&);

  public:
    UDPUnblockMulticastSourcesCommand();
    UDPUnblockMulticastSourcesCommand(const UDPUnblockMulticastSourcesCommand& other);
    virtual ~UDPUnblockMulticastSourcesCommand();
    UDPUnblockMulticastSourcesCommand& operator=(const UDPUnblockMulticastSourcesCommand& other);
    virtual UDPUnblockMulticastSourcesCommand *dup() const override {return new UDPUnblockMulticastSourcesCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
    virtual L3Address& getMulticastAddr();
    virtual const L3Address& getMulticastAddr() const {return const_cast<UDPUnblockMulticastSourcesCommand*>(this)->getMulticastAddr();}
    virtual void setMulticastAddr(const L3Address& multicastAddr);
    virtual void setSourceListArraySize(unsigned int size);
    virtual unsigned int getSourceListArraySize() const;
    virtual L3Address& getSourceList(unsigned int k);
    virtual const L3Address& getSourceList(unsigned int k) const {return const_cast<UDPUnblockMulticastSourcesCommand*>(this)->getSourceList(k);}
    virtual void setSourceList(unsigned int k, const L3Address& sourceList);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPUnblockMulticastSourcesCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPUnblockMulticastSourcesCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:313</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to join a multicast group
 * // only for the selected sources.
 * //
 * // see IP_ADD_SOURCE_MEMBERSHIP socket option
 * class UDPJoinMulticastSourcesCommand extends UDPSetOptionCommand
 * {
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class UDPJoinMulticastSourcesCommand : public ::inet::UDPSetOptionCommand
{
  protected:
    int interfaceId;
    L3Address multicastAddr;
    L3Address *sourceList; // array ptr
    unsigned int sourceList_arraysize;

  private:
    void copy(const UDPJoinMulticastSourcesCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPJoinMulticastSourcesCommand&);

  public:
    UDPJoinMulticastSourcesCommand();
    UDPJoinMulticastSourcesCommand(const UDPJoinMulticastSourcesCommand& other);
    virtual ~UDPJoinMulticastSourcesCommand();
    UDPJoinMulticastSourcesCommand& operator=(const UDPJoinMulticastSourcesCommand& other);
    virtual UDPJoinMulticastSourcesCommand *dup() const override {return new UDPJoinMulticastSourcesCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
    virtual L3Address& getMulticastAddr();
    virtual const L3Address& getMulticastAddr() const {return const_cast<UDPJoinMulticastSourcesCommand*>(this)->getMulticastAddr();}
    virtual void setMulticastAddr(const L3Address& multicastAddr);
    virtual void setSourceListArraySize(unsigned int size);
    virtual unsigned int getSourceListArraySize() const;
    virtual L3Address& getSourceList(unsigned int k);
    virtual const L3Address& getSourceList(unsigned int k) const {return const_cast<UDPJoinMulticastSourcesCommand*>(this)->getSourceList(k);}
    virtual void setSourceList(unsigned int k, const L3Address& sourceList);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPJoinMulticastSourcesCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPJoinMulticastSourcesCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:325</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to leave a multicast group
 * // for the selected sources.
 * //
 * // see IP_DROP_SOURCE_MEMBERSHIP socket option
 * class UDPLeaveMulticastSourcesCommand extends UDPSetOptionCommand
 * {
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class UDPLeaveMulticastSourcesCommand : public ::inet::UDPSetOptionCommand
{
  protected:
    int interfaceId;
    L3Address multicastAddr;
    L3Address *sourceList; // array ptr
    unsigned int sourceList_arraysize;

  private:
    void copy(const UDPLeaveMulticastSourcesCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPLeaveMulticastSourcesCommand&);

  public:
    UDPLeaveMulticastSourcesCommand();
    UDPLeaveMulticastSourcesCommand(const UDPLeaveMulticastSourcesCommand& other);
    virtual ~UDPLeaveMulticastSourcesCommand();
    UDPLeaveMulticastSourcesCommand& operator=(const UDPLeaveMulticastSourcesCommand& other);
    virtual UDPLeaveMulticastSourcesCommand *dup() const override {return new UDPLeaveMulticastSourcesCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
    virtual L3Address& getMulticastAddr();
    virtual const L3Address& getMulticastAddr() const {return const_cast<UDPLeaveMulticastSourcesCommand*>(this)->getMulticastAddr();}
    virtual void setMulticastAddr(const L3Address& multicastAddr);
    virtual void setSourceListArraySize(unsigned int size);
    virtual unsigned int getSourceListArraySize() const;
    virtual L3Address& getSourceList(unsigned int k);
    virtual const L3Address& getSourceList(unsigned int k) const {return const_cast<UDPLeaveMulticastSourcesCommand*>(this)->getSourceList(k);}
    virtual void setSourceList(unsigned int k, const L3Address& sourceList);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPLeaveMulticastSourcesCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPLeaveMulticastSourcesCommand& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:331</tt> by nedtool.
 * <pre>
 * enum UDPSourceFilterMode
 * {
 *     UDP_INCLUDE_MCAST_SOURCES = 1;
 *     UDP_EXCLUDE_MCAST_SOURCES = 2;
 * }
 * </pre>
 */
enum UDPSourceFilterMode {
    UDP_INCLUDE_MCAST_SOURCES = 1,
    UDP_EXCLUDE_MCAST_SOURCES = 2
};

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/contract/udp/UDPControlInfo.msg:341</tt> by nedtool.
 * <pre>
 * //
 * // Control info for letting an UDP socket to specify the excluded/included
 * // sources for a multicast group.
 * //
 * // Unlike Block/Unblock/Join/LeaveMulticastSource commands, this method is
 * // not incremental.
 * //
 * class UDPSetMulticastSourceFilterCommand extends UDPSetOptionCommand
 * {
 *     int interfaceId;
 *     L3Address multicastAddr;
 *     int filterMode \@enum(UDPSourceFilterMode);
 *     L3Address sourceList[];
 * }
 * </pre>
 */
class UDPSetMulticastSourceFilterCommand : public ::inet::UDPSetOptionCommand
{
  protected:
    int interfaceId;
    L3Address multicastAddr;
    int filterMode;
    L3Address *sourceList; // array ptr
    unsigned int sourceList_arraysize;

  private:
    void copy(const UDPSetMulticastSourceFilterCommand& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UDPSetMulticastSourceFilterCommand&);

  public:
    UDPSetMulticastSourceFilterCommand();
    UDPSetMulticastSourceFilterCommand(const UDPSetMulticastSourceFilterCommand& other);
    virtual ~UDPSetMulticastSourceFilterCommand();
    UDPSetMulticastSourceFilterCommand& operator=(const UDPSetMulticastSourceFilterCommand& other);
    virtual UDPSetMulticastSourceFilterCommand *dup() const override {return new UDPSetMulticastSourceFilterCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getInterfaceId() const;
    virtual void setInterfaceId(int interfaceId);
    virtual L3Address& getMulticastAddr();
    virtual const L3Address& getMulticastAddr() const {return const_cast<UDPSetMulticastSourceFilterCommand*>(this)->getMulticastAddr();}
    virtual void setMulticastAddr(const L3Address& multicastAddr);
    virtual int getFilterMode() const;
    virtual void setFilterMode(int filterMode);
    virtual void setSourceListArraySize(unsigned int size);
    virtual unsigned int getSourceListArraySize() const;
    virtual L3Address& getSourceList(unsigned int k);
    virtual const L3Address& getSourceList(unsigned int k) const {return const_cast<UDPSetMulticastSourceFilterCommand*>(this)->getSourceList(k);}
    virtual void setSourceList(unsigned int k, const L3Address& sourceList);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const UDPSetMulticastSourceFilterCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, UDPSetMulticastSourceFilterCommand& obj) {obj.parsimUnpack(b);}

} // namespace inet

#endif // ifndef __INET_UDPCONTROLINFO_M_H

