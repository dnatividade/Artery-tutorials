//
// Generated file, do not edit! Created by nedtool 5.7 from /home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg.
//

#ifndef __INET__SCTP_SCTPMESSAGE_M_H
#define __INET__SCTP_SCTPMESSAGE_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0507
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include "inet/networklayer/common/L3Address.h"
// }}


namespace inet {
namespace sctp {

// cplusplus {{
typedef cPacket *cPacketPtr;
// }}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:36</tt> by nedtool.
 * <pre>
 * message SCTPMessage extends cPacket
 * {
 *     \@customize(true);
 *     // Source Port
 *     uint16 srcPort;
 *     // Destination Port
 *     uint16 destPort;
 *     // Verification Tag
 *     uint32 tag;
 *     bool checksumOk;
 *     abstract cPacketPtr chunks[];
 * }
 * </pre>
 *
 * SCTPMessage_Base is only useful if it gets subclassed, and SCTPMessage is derived from it.
 * The minimum code to be written for SCTPMessage is the following:
 *
 * <pre>
 * class SCTPMessage : public SCTPMessage_Base
 * {
 *   private:
 *     void copy(const SCTPMessage& other) { ... }

 *   public:
 *     SCTPMessage(const char *name=nullptr, short kind=0) : SCTPMessage_Base(name,kind) {}
 *     SCTPMessage(const SCTPMessage& other) : SCTPMessage_Base(other) {copy(other);}
 *     SCTPMessage& operator=(const SCTPMessage& other) {if (this==&other) return *this; SCTPMessage_Base::operator=(other); copy(other); return *this;}
 *     virtual SCTPMessage *dup() const override {return new SCTPMessage(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SCTPMessage_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SCTPMessage)
 * </pre>
 */
class SCTPMessage_Base : public ::omnetpp::cPacket
{
  protected:
    uint16_t srcPort;
    uint16_t destPort;
    uint32_t tag;
    bool checksumOk;

  private:
    void copy(const SCTPMessage_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPMessage_Base&);
    // make constructors protected to avoid instantiation
    SCTPMessage_Base(const char *name=nullptr, short kind=0);
    SCTPMessage_Base(const SCTPMessage_Base& other);
    // make assignment operator protected to force the user override it
    SCTPMessage_Base& operator=(const SCTPMessage_Base& other);

  public:
    virtual ~SCTPMessage_Base();
    virtual SCTPMessage_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SCTPMessage");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getSrcPort() const;
    virtual void setSrcPort(uint16_t srcPort);
    virtual uint16_t getDestPort() const;
    virtual void setDestPort(uint16_t destPort);
    virtual uint32_t getTag() const;
    virtual void setTag(uint32_t tag);
    virtual bool getChecksumOk() const;
    virtual void setChecksumOk(bool checksumOk);
    virtual void setChunksArraySize(unsigned int size) = 0;
    virtual unsigned int getChunksArraySize() const = 0;
    virtual cPacketPtr& getChunks(unsigned int k) = 0;
    virtual const cPacketPtr& getChunks(unsigned int k) const {return const_cast<SCTPMessage_Base*>(this)->getChunks(k);}
    virtual void setChunks(unsigned int k, const cPacketPtr& chunks) = 0;
};

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:50</tt> by nedtool.
 * <pre>
 * message SCTPChunk extends cPacket
 * {
 *     \@customize(false);
 *     // Chunk Type
 *     uint8 chunkType;
 *     uint32 flags;
 * }
 * </pre>
 */
class SCTPChunk : public ::omnetpp::cPacket
{
  protected:
    uint8_t chunkType;
    uint32_t flags;

  private:
    void copy(const SCTPChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPChunk&);

  public:
    SCTPChunk(const char *name=nullptr, short kind=0);
    SCTPChunk(const SCTPChunk& other);
    virtual ~SCTPChunk();
    SCTPChunk& operator=(const SCTPChunk& other);
    virtual SCTPChunk *dup() const override {return new SCTPChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint8_t getChunkType() const;
    virtual void setChunkType(uint8_t chunkType);
    virtual uint32_t getFlags() const;
    virtual void setFlags(uint32_t flags);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:58</tt> by nedtool.
 * <pre>
 * message SCTPInitChunk extends SCTPChunk
 * {
 *     // Initiate Tag
 *     uint32 initTag;
 *     // Advertised Receiver Window
 *     uint32 a_rwnd;
 *     // Number of Outbound Streams
 *     uint16 noOutStreams;
 *     // Number of Inbound Streams
 *     uint16 noInStreams;
 *     // Initial TSN
 *     uint32 initTSN;
 *     bool forwardTsn;
 *     bool ipv4Supported;
 *     bool ipv6Supported;
 *     L3Address addresses[];
 *     uint8 unrecognizedParameters[]; //Will be filled by the Parser, if unrecognized Parameters arrive.
 *     uint32 msg_rwnd;
 *     uint16 chunkTypes[]; //Chunk list parameter, i.e. for SCTP AUTH
 *     uint16 sepChunks[]; //Supported extensions parameter, i.e. for StreamReset
 *     uint16 hmacTypes[]; //HMAC Identifier for HMAC algorithm parameter
 *     uint8 random[]; //Random Parameter for SCTP AUTH
 * }
 * </pre>
 */
class SCTPInitChunk : public ::inet::sctp::SCTPChunk
{
  protected:
    uint32_t initTag;
    uint32_t a_rwnd;
    uint16_t noOutStreams;
    uint16_t noInStreams;
    uint32_t initTSN;
    bool forwardTsn;
    bool ipv4Supported;
    bool ipv6Supported;
    L3Address *addresses; // array ptr
    unsigned int addresses_arraysize;
    uint8_t *unrecognizedParameters; // array ptr
    unsigned int unrecognizedParameters_arraysize;
    uint32_t msg_rwnd;
    uint16_t *chunkTypes; // array ptr
    unsigned int chunkTypes_arraysize;
    uint16_t *sepChunks; // array ptr
    unsigned int sepChunks_arraysize;
    uint16_t *hmacTypes; // array ptr
    unsigned int hmacTypes_arraysize;
    uint8_t *random; // array ptr
    unsigned int random_arraysize;

  private:
    void copy(const SCTPInitChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPInitChunk&);

  public:
    SCTPInitChunk(const char *name=nullptr, short kind=0);
    SCTPInitChunk(const SCTPInitChunk& other);
    virtual ~SCTPInitChunk();
    SCTPInitChunk& operator=(const SCTPInitChunk& other);
    virtual SCTPInitChunk *dup() const override {return new SCTPInitChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getInitTag() const;
    virtual void setInitTag(uint32_t initTag);
    virtual uint32_t getA_rwnd() const;
    virtual void setA_rwnd(uint32_t a_rwnd);
    virtual uint16_t getNoOutStreams() const;
    virtual void setNoOutStreams(uint16_t noOutStreams);
    virtual uint16_t getNoInStreams() const;
    virtual void setNoInStreams(uint16_t noInStreams);
    virtual uint32_t getInitTSN() const;
    virtual void setInitTSN(uint32_t initTSN);
    virtual bool getForwardTsn() const;
    virtual void setForwardTsn(bool forwardTsn);
    virtual bool getIpv4Supported() const;
    virtual void setIpv4Supported(bool ipv4Supported);
    virtual bool getIpv6Supported() const;
    virtual void setIpv6Supported(bool ipv6Supported);
    virtual void setAddressesArraySize(unsigned int size);
    virtual unsigned int getAddressesArraySize() const;
    virtual L3Address& getAddresses(unsigned int k);
    virtual const L3Address& getAddresses(unsigned int k) const {return const_cast<SCTPInitChunk*>(this)->getAddresses(k);}
    virtual void setAddresses(unsigned int k, const L3Address& addresses);
    virtual void setUnrecognizedParametersArraySize(unsigned int size);
    virtual unsigned int getUnrecognizedParametersArraySize() const;
    virtual uint8_t getUnrecognizedParameters(unsigned int k) const;
    virtual void setUnrecognizedParameters(unsigned int k, uint8_t unrecognizedParameters);
    virtual uint32_t getMsg_rwnd() const;
    virtual void setMsg_rwnd(uint32_t msg_rwnd);
    virtual void setChunkTypesArraySize(unsigned int size);
    virtual unsigned int getChunkTypesArraySize() const;
    virtual uint16_t getChunkTypes(unsigned int k) const;
    virtual void setChunkTypes(unsigned int k, uint16_t chunkTypes);
    virtual void setSepChunksArraySize(unsigned int size);
    virtual unsigned int getSepChunksArraySize() const;
    virtual uint16_t getSepChunks(unsigned int k) const;
    virtual void setSepChunks(unsigned int k, uint16_t sepChunks);
    virtual void setHmacTypesArraySize(unsigned int size);
    virtual unsigned int getHmacTypesArraySize() const;
    virtual uint16_t getHmacTypes(unsigned int k) const;
    virtual void setHmacTypes(unsigned int k, uint16_t hmacTypes);
    virtual void setRandomArraySize(unsigned int size);
    virtual unsigned int getRandomArraySize() const;
    virtual uint8_t getRandom(unsigned int k) const;
    virtual void setRandom(unsigned int k, uint8_t random);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPInitChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPInitChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:82</tt> by nedtool.
 * <pre>
 * message SCTPInitAckChunk extends SCTPChunk
 * {
 *     // Initiate Tag
 *     uint32 initTag;
 *     // Advertised Receiver Window
 *     uint32 a_rwnd;
 *     // Number of Outbound Streams
 *     uint16 noOutStreams;
 *     // Number of Inbound Streams
 *     uint16 noInStreams;
 *     // Initial TSN
 *     uint32 initTSN;
 *     bool forwardTsn;
 *     bool ipv4Supported;
 *     bool ipv6Supported;
 *     L3Address addresses[];
 *     char cookie[];
 *     uint8 unrecognizedParameters[];
 *     cPacketPtr stateCookie = nullptr;
 *     uint32 msg_rwnd;
 *     uint8 random[]; //Random Number
 *     uint16 chunkTypes[];
 *     uint16 sepChunks[]; //Supported extensions parameter, i.e. for StreamReset
 *     uint16 hmacTypes[];
 * }
 * </pre>
 */
class SCTPInitAckChunk : public ::inet::sctp::SCTPChunk
{
  protected:
    uint32_t initTag;
    uint32_t a_rwnd;
    uint16_t noOutStreams;
    uint16_t noInStreams;
    uint32_t initTSN;
    bool forwardTsn;
    bool ipv4Supported;
    bool ipv6Supported;
    L3Address *addresses; // array ptr
    unsigned int addresses_arraysize;
    char *cookie; // array ptr
    unsigned int cookie_arraysize;
    uint8_t *unrecognizedParameters; // array ptr
    unsigned int unrecognizedParameters_arraysize;
    cPacketPtr stateCookie;
    uint32_t msg_rwnd;
    uint8_t *random; // array ptr
    unsigned int random_arraysize;
    uint16_t *chunkTypes; // array ptr
    unsigned int chunkTypes_arraysize;
    uint16_t *sepChunks; // array ptr
    unsigned int sepChunks_arraysize;
    uint16_t *hmacTypes; // array ptr
    unsigned int hmacTypes_arraysize;

  private:
    void copy(const SCTPInitAckChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPInitAckChunk&);

  public:
    SCTPInitAckChunk(const char *name=nullptr, short kind=0);
    SCTPInitAckChunk(const SCTPInitAckChunk& other);
    virtual ~SCTPInitAckChunk();
    SCTPInitAckChunk& operator=(const SCTPInitAckChunk& other);
    virtual SCTPInitAckChunk *dup() const override {return new SCTPInitAckChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getInitTag() const;
    virtual void setInitTag(uint32_t initTag);
    virtual uint32_t getA_rwnd() const;
    virtual void setA_rwnd(uint32_t a_rwnd);
    virtual uint16_t getNoOutStreams() const;
    virtual void setNoOutStreams(uint16_t noOutStreams);
    virtual uint16_t getNoInStreams() const;
    virtual void setNoInStreams(uint16_t noInStreams);
    virtual uint32_t getInitTSN() const;
    virtual void setInitTSN(uint32_t initTSN);
    virtual bool getForwardTsn() const;
    virtual void setForwardTsn(bool forwardTsn);
    virtual bool getIpv4Supported() const;
    virtual void setIpv4Supported(bool ipv4Supported);
    virtual bool getIpv6Supported() const;
    virtual void setIpv6Supported(bool ipv6Supported);
    virtual void setAddressesArraySize(unsigned int size);
    virtual unsigned int getAddressesArraySize() const;
    virtual L3Address& getAddresses(unsigned int k);
    virtual const L3Address& getAddresses(unsigned int k) const {return const_cast<SCTPInitAckChunk*>(this)->getAddresses(k);}
    virtual void setAddresses(unsigned int k, const L3Address& addresses);
    virtual void setCookieArraySize(unsigned int size);
    virtual unsigned int getCookieArraySize() const;
    virtual char getCookie(unsigned int k) const;
    virtual void setCookie(unsigned int k, char cookie);
    virtual void setUnrecognizedParametersArraySize(unsigned int size);
    virtual unsigned int getUnrecognizedParametersArraySize() const;
    virtual uint8_t getUnrecognizedParameters(unsigned int k) const;
    virtual void setUnrecognizedParameters(unsigned int k, uint8_t unrecognizedParameters);
    virtual cPacketPtr& getStateCookie();
    virtual const cPacketPtr& getStateCookie() const {return const_cast<SCTPInitAckChunk*>(this)->getStateCookie();}
    virtual void setStateCookie(const cPacketPtr& stateCookie);
    virtual uint32_t getMsg_rwnd() const;
    virtual void setMsg_rwnd(uint32_t msg_rwnd);
    virtual void setRandomArraySize(unsigned int size);
    virtual unsigned int getRandomArraySize() const;
    virtual uint8_t getRandom(unsigned int k) const;
    virtual void setRandom(unsigned int k, uint8_t random);
    virtual void setChunkTypesArraySize(unsigned int size);
    virtual unsigned int getChunkTypesArraySize() const;
    virtual uint16_t getChunkTypes(unsigned int k) const;
    virtual void setChunkTypes(unsigned int k, uint16_t chunkTypes);
    virtual void setSepChunksArraySize(unsigned int size);
    virtual unsigned int getSepChunksArraySize() const;
    virtual uint16_t getSepChunks(unsigned int k) const;
    virtual void setSepChunks(unsigned int k, uint16_t sepChunks);
    virtual void setHmacTypesArraySize(unsigned int size);
    virtual unsigned int getHmacTypesArraySize() const;
    virtual uint16_t getHmacTypes(unsigned int k) const;
    virtual void setHmacTypes(unsigned int k, uint16_t hmacTypes);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPInitAckChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPInitAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:110</tt> by nedtool.
 * <pre>
 * message SCTPCookieEchoChunk extends SCTPChunk
 * {
 *     char cookie[];
 *     cPacketPtr stateCookie = nullptr;
 *     uint8 unrecognizedParameters[]; //for the serializer to send an Error chunk bundled with a Cookie-Echo
 * }
 * </pre>
 */
class SCTPCookieEchoChunk : public ::inet::sctp::SCTPChunk
{
  protected:
    char *cookie; // array ptr
    unsigned int cookie_arraysize;
    cPacketPtr stateCookie;
    uint8_t *unrecognizedParameters; // array ptr
    unsigned int unrecognizedParameters_arraysize;

  private:
    void copy(const SCTPCookieEchoChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPCookieEchoChunk&);

  public:
    SCTPCookieEchoChunk(const char *name=nullptr, short kind=0);
    SCTPCookieEchoChunk(const SCTPCookieEchoChunk& other);
    virtual ~SCTPCookieEchoChunk();
    SCTPCookieEchoChunk& operator=(const SCTPCookieEchoChunk& other);
    virtual SCTPCookieEchoChunk *dup() const override {return new SCTPCookieEchoChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setCookieArraySize(unsigned int size);
    virtual unsigned int getCookieArraySize() const;
    virtual char getCookie(unsigned int k) const;
    virtual void setCookie(unsigned int k, char cookie);
    virtual cPacketPtr& getStateCookie();
    virtual const cPacketPtr& getStateCookie() const {return const_cast<SCTPCookieEchoChunk*>(this)->getStateCookie();}
    virtual void setStateCookie(const cPacketPtr& stateCookie);
    virtual void setUnrecognizedParametersArraySize(unsigned int size);
    virtual unsigned int getUnrecognizedParametersArraySize() const;
    virtual uint8_t getUnrecognizedParameters(unsigned int k) const;
    virtual void setUnrecognizedParameters(unsigned int k, uint8_t unrecognizedParameters);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPCookieEchoChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPCookieEchoChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:117</tt> by nedtool.
 * <pre>
 * message SCTPCookie extends cPacket
 * {
 *     simtime_t creationTime;
 *     uint32 localTag;
 *     uint32 peerTag;
 *     uint8 localTieTag[];
 *     uint8 peerTieTag[];
 * }
 * </pre>
 */
class SCTPCookie : public ::omnetpp::cPacket
{
  protected:
    ::omnetpp::simtime_t creationTime;
    uint32_t localTag;
    uint32_t peerTag;
    uint8_t *localTieTag; // array ptr
    unsigned int localTieTag_arraysize;
    uint8_t *peerTieTag; // array ptr
    unsigned int peerTieTag_arraysize;

  private:
    void copy(const SCTPCookie& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPCookie&);

  public:
    SCTPCookie(const char *name=nullptr, short kind=0);
    SCTPCookie(const SCTPCookie& other);
    virtual ~SCTPCookie();
    SCTPCookie& operator=(const SCTPCookie& other);
    virtual SCTPCookie *dup() const override {return new SCTPCookie(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual ::omnetpp::simtime_t getCreationTime() const;
    virtual void setCreationTime(::omnetpp::simtime_t creationTime);
    virtual uint32_t getLocalTag() const;
    virtual void setLocalTag(uint32_t localTag);
    virtual uint32_t getPeerTag() const;
    virtual void setPeerTag(uint32_t peerTag);
    virtual void setLocalTieTagArraySize(unsigned int size);
    virtual unsigned int getLocalTieTagArraySize() const;
    virtual uint8_t getLocalTieTag(unsigned int k) const;
    virtual void setLocalTieTag(unsigned int k, uint8_t localTieTag);
    virtual void setPeerTieTagArraySize(unsigned int size);
    virtual unsigned int getPeerTieTagArraySize() const;
    virtual uint8_t getPeerTieTag(unsigned int k) const;
    virtual void setPeerTieTag(unsigned int k, uint8_t peerTieTag);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPCookie& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPCookie& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:126</tt> by nedtool.
 * <pre>
 * message SCTPCookieAckChunk extends SCTPChunk
 * {
 * }
 * </pre>
 */
class SCTPCookieAckChunk : public ::inet::sctp::SCTPChunk
{
  protected:

  private:
    void copy(const SCTPCookieAckChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPCookieAckChunk&);

  public:
    SCTPCookieAckChunk(const char *name=nullptr, short kind=0);
    SCTPCookieAckChunk(const SCTPCookieAckChunk& other);
    virtual ~SCTPCookieAckChunk();
    SCTPCookieAckChunk& operator=(const SCTPCookieAckChunk& other);
    virtual SCTPCookieAckChunk *dup() const override {return new SCTPCookieAckChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPCookieAckChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPCookieAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:130</tt> by nedtool.
 * <pre>
 * message SCTPDataMsg extends cPacket
 * {
 *     // Chunk Flags
 *     bool eBit = 0;
 *     bool bBit = 0;
 *     simtime_t enqueuingTime;
 *     simtime_t expiryTime;
 *     uint32 ppid;
 *     L3Address initialDestination;
 *     uint32 msgNum;
 *     uint16 sid;
 *     bool ordered;
 *     uint32 booksize;
 *     uint32 rtx;
 *     bool fragment;
 *     uint32 prMethod;
 *     uint32 priority;
 *     bool strReset;
 *     bool sackNow;
 * }
 * </pre>
 */
class SCTPDataMsg : public ::omnetpp::cPacket
{
  protected:
    bool eBit;
    bool bBit;
    ::omnetpp::simtime_t enqueuingTime;
    ::omnetpp::simtime_t expiryTime;
    uint32_t ppid;
    L3Address initialDestination;
    uint32_t msgNum;
    uint16_t sid;
    bool ordered;
    uint32_t booksize;
    uint32_t rtx;
    bool fragment;
    uint32_t prMethod;
    uint32_t priority;
    bool strReset;
    bool sackNow;

  private:
    void copy(const SCTPDataMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPDataMsg&);

  public:
    SCTPDataMsg(const char *name=nullptr, short kind=0);
    SCTPDataMsg(const SCTPDataMsg& other);
    virtual ~SCTPDataMsg();
    SCTPDataMsg& operator=(const SCTPDataMsg& other);
    virtual SCTPDataMsg *dup() const override {return new SCTPDataMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getEBit() const;
    virtual void setEBit(bool eBit);
    virtual bool getBBit() const;
    virtual void setBBit(bool bBit);
    virtual ::omnetpp::simtime_t getEnqueuingTime() const;
    virtual void setEnqueuingTime(::omnetpp::simtime_t enqueuingTime);
    virtual ::omnetpp::simtime_t getExpiryTime() const;
    virtual void setExpiryTime(::omnetpp::simtime_t expiryTime);
    virtual uint32_t getPpid() const;
    virtual void setPpid(uint32_t ppid);
    virtual L3Address& getInitialDestination();
    virtual const L3Address& getInitialDestination() const {return const_cast<SCTPDataMsg*>(this)->getInitialDestination();}
    virtual void setInitialDestination(const L3Address& initialDestination);
    virtual uint32_t getMsgNum() const;
    virtual void setMsgNum(uint32_t msgNum);
    virtual uint16_t getSid() const;
    virtual void setSid(uint16_t sid);
    virtual bool getOrdered() const;
    virtual void setOrdered(bool ordered);
    virtual uint32_t getBooksize() const;
    virtual void setBooksize(uint32_t booksize);
    virtual uint32_t getRtx() const;
    virtual void setRtx(uint32_t rtx);
    virtual bool getFragment() const;
    virtual void setFragment(bool fragment);
    virtual uint32_t getPrMethod() const;
    virtual void setPrMethod(uint32_t prMethod);
    virtual uint32_t getPriority() const;
    virtual void setPriority(uint32_t priority);
    virtual bool getStrReset() const;
    virtual void setStrReset(bool strReset);
    virtual bool getSackNow() const;
    virtual void setSackNow(bool sackNow);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPDataMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPDataMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:151</tt> by nedtool.
 * <pre>
 * message SCTPDataChunk extends SCTPChunk
 * {
 *     // Chunk Flags
 *     bool eBit = 0;
 *     bool bBit = 0;
 *     bool uBit = 0;
 *     bool iBit = 0;
 *     // Transmission Sequence Number
 *     uint32 tsn;
 *     // Stream identifier
 *     uint16 sid;
 *     // Stream Sequence Number
 *     uint16 ssn;
 *     // Payload Protocol Identifier
 *     uint32 ppid;
 *     simtime_t enqueuingTime;
 *     simtime_t firstSendTime;
 * }
 * </pre>
 */
class SCTPDataChunk : public ::inet::sctp::SCTPChunk
{
  protected:
    bool eBit;
    bool bBit;
    bool uBit;
    bool iBit;
    uint32_t tsn;
    uint16_t sid;
    uint16_t ssn;
    uint32_t ppid;
    ::omnetpp::simtime_t enqueuingTime;
    ::omnetpp::simtime_t firstSendTime;

  private:
    void copy(const SCTPDataChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPDataChunk&);

  public:
    SCTPDataChunk(const char *name=nullptr, short kind=0);
    SCTPDataChunk(const SCTPDataChunk& other);
    virtual ~SCTPDataChunk();
    SCTPDataChunk& operator=(const SCTPDataChunk& other);
    virtual SCTPDataChunk *dup() const override {return new SCTPDataChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getEBit() const;
    virtual void setEBit(bool eBit);
    virtual bool getBBit() const;
    virtual void setBBit(bool bBit);
    virtual bool getUBit() const;
    virtual void setUBit(bool uBit);
    virtual bool getIBit() const;
    virtual void setIBit(bool iBit);
    virtual uint32_t getTsn() const;
    virtual void setTsn(uint32_t tsn);
    virtual uint16_t getSid() const;
    virtual void setSid(uint16_t sid);
    virtual uint16_t getSsn() const;
    virtual void setSsn(uint16_t ssn);
    virtual uint32_t getPpid() const;
    virtual void setPpid(uint32_t ppid);
    virtual ::omnetpp::simtime_t getEnqueuingTime() const;
    virtual void setEnqueuingTime(::omnetpp::simtime_t enqueuingTime);
    virtual ::omnetpp::simtime_t getFirstSendTime() const;
    virtual void setFirstSendTime(::omnetpp::simtime_t firstSendTime);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPDataChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPDataChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:170</tt> by nedtool.
 * <pre>
 * message SCTPForwardTsnChunk extends SCTPChunk
 * {
 *     uint32 newCumTsn;
 *     uint16 sid[];
 *     short ssn[]; // set -1 in case of unordered delivery
 * }
 * </pre>
 */
class SCTPForwardTsnChunk : public ::inet::sctp::SCTPChunk
{
  protected:
    uint32_t newCumTsn;
    uint16_t *sid; // array ptr
    unsigned int sid_arraysize;
    short *ssn; // array ptr
    unsigned int ssn_arraysize;

  private:
    void copy(const SCTPForwardTsnChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPForwardTsnChunk&);

  public:
    SCTPForwardTsnChunk(const char *name=nullptr, short kind=0);
    SCTPForwardTsnChunk(const SCTPForwardTsnChunk& other);
    virtual ~SCTPForwardTsnChunk();
    SCTPForwardTsnChunk& operator=(const SCTPForwardTsnChunk& other);
    virtual SCTPForwardTsnChunk *dup() const override {return new SCTPForwardTsnChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getNewCumTsn() const;
    virtual void setNewCumTsn(uint32_t newCumTsn);
    virtual void setSidArraySize(unsigned int size);
    virtual unsigned int getSidArraySize() const;
    virtual uint16_t getSid(unsigned int k) const;
    virtual void setSid(unsigned int k, uint16_t sid);
    virtual void setSsnArraySize(unsigned int size);
    virtual unsigned int getSsnArraySize() const;
    virtual short getSsn(unsigned int k) const;
    virtual void setSsn(unsigned int k, short ssn);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPForwardTsnChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPForwardTsnChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:177</tt> by nedtool.
 * <pre>
 * message SCTPSackChunk extends SCTPChunk
 * {
 *     // Cumulative TSN Ack
 *     uint32 cumTsnAck;
 *     // Advertised Receiver Window Credit
 *     uint32 a_rwnd;
 *     // Number of Gap Ack Blocks
 *     uint16 numGaps;
 *     // Number of Non-Revokable Gap Ack Blocks
 *     uint16 numNrGaps;
 *     // Number of Duplicate TSNs
 *     uint16 numDupTsns;
 *     // Start and End of Gap Ack Blocks
 *     bool isNrSack;
 *     uint32 gapStart[];
 *     uint32 gapStop[];
 *     uint32 dupTsns[];
 *     uint32 sackSeqNum = 0;
 *     uint32 nrGapStart[];
 *     uint32 nrGapStop[];
 *     uint32 msg_rwnd;
 *     uint8 dacPacketsRcvd = 0;
 *     bool nrSubtractRGaps = false;
 * }
 * </pre>
 */
class SCTPSackChunk : public ::inet::sctp::SCTPChunk
{
  protected:
    uint32_t cumTsnAck;
    uint32_t a_rwnd;
    uint16_t numGaps;
    uint16_t numNrGaps;
    uint16_t numDupTsns;
    bool isNrSack;
    uint32_t *gapStart; // array ptr
    unsigned int gapStart_arraysize;
    uint32_t *gapStop; // array ptr
    unsigned int gapStop_arraysize;
    uint32_t *dupTsns; // array ptr
    unsigned int dupTsns_arraysize;
    uint32_t sackSeqNum;
    uint32_t *nrGapStart; // array ptr
    unsigned int nrGapStart_arraysize;
    uint32_t *nrGapStop; // array ptr
    unsigned int nrGapStop_arraysize;
    uint32_t msg_rwnd;
    uint8_t dacPacketsRcvd;
    bool nrSubtractRGaps;

  private:
    void copy(const SCTPSackChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPSackChunk&);

  public:
    SCTPSackChunk(const char *name=nullptr, short kind=0);
    SCTPSackChunk(const SCTPSackChunk& other);
    virtual ~SCTPSackChunk();
    SCTPSackChunk& operator=(const SCTPSackChunk& other);
    virtual SCTPSackChunk *dup() const override {return new SCTPSackChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getCumTsnAck() const;
    virtual void setCumTsnAck(uint32_t cumTsnAck);
    virtual uint32_t getA_rwnd() const;
    virtual void setA_rwnd(uint32_t a_rwnd);
    virtual uint16_t getNumGaps() const;
    virtual void setNumGaps(uint16_t numGaps);
    virtual uint16_t getNumNrGaps() const;
    virtual void setNumNrGaps(uint16_t numNrGaps);
    virtual uint16_t getNumDupTsns() const;
    virtual void setNumDupTsns(uint16_t numDupTsns);
    virtual bool getIsNrSack() const;
    virtual void setIsNrSack(bool isNrSack);
    virtual void setGapStartArraySize(unsigned int size);
    virtual unsigned int getGapStartArraySize() const;
    virtual uint32_t getGapStart(unsigned int k) const;
    virtual void setGapStart(unsigned int k, uint32_t gapStart);
    virtual void setGapStopArraySize(unsigned int size);
    virtual unsigned int getGapStopArraySize() const;
    virtual uint32_t getGapStop(unsigned int k) const;
    virtual void setGapStop(unsigned int k, uint32_t gapStop);
    virtual void setDupTsnsArraySize(unsigned int size);
    virtual unsigned int getDupTsnsArraySize() const;
    virtual uint32_t getDupTsns(unsigned int k) const;
    virtual void setDupTsns(unsigned int k, uint32_t dupTsns);
    virtual uint32_t getSackSeqNum() const;
    virtual void setSackSeqNum(uint32_t sackSeqNum);
    virtual void setNrGapStartArraySize(unsigned int size);
    virtual unsigned int getNrGapStartArraySize() const;
    virtual uint32_t getNrGapStart(unsigned int k) const;
    virtual void setNrGapStart(unsigned int k, uint32_t nrGapStart);
    virtual void setNrGapStopArraySize(unsigned int size);
    virtual unsigned int getNrGapStopArraySize() const;
    virtual uint32_t getNrGapStop(unsigned int k) const;
    virtual void setNrGapStop(unsigned int k, uint32_t nrGapStop);
    virtual uint32_t getMsg_rwnd() const;
    virtual void setMsg_rwnd(uint32_t msg_rwnd);
    virtual uint8_t getDacPacketsRcvd() const;
    virtual void setDacPacketsRcvd(uint8_t dacPacketsRcvd);
    virtual bool getNrSubtractRGaps() const;
    virtual void setNrSubtractRGaps(bool nrSubtractRGaps);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPSackChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPSackChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:202</tt> by nedtool.
 * <pre>
 * message SCTPAbortChunk extends SCTPChunk
 * {
 *     // Chunk Flags
 *     bool T_Bit = 0;
 * }
 * </pre>
 */
class SCTPAbortChunk : public ::inet::sctp::SCTPChunk
{
  protected:
    bool T_Bit;

  private:
    void copy(const SCTPAbortChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPAbortChunk&);

  public:
    SCTPAbortChunk(const char *name=nullptr, short kind=0);
    SCTPAbortChunk(const SCTPAbortChunk& other);
    virtual ~SCTPAbortChunk();
    SCTPAbortChunk& operator=(const SCTPAbortChunk& other);
    virtual SCTPAbortChunk *dup() const override {return new SCTPAbortChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getT_Bit() const;
    virtual void setT_Bit(bool T_Bit);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPAbortChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPAbortChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:208</tt> by nedtool.
 * <pre>
 * message SCTPHeartbeatChunk extends SCTPChunk
 * {
 *     L3Address remoteAddr;
 *     simtime_t timeField;
 *     char info[];
 * }
 * </pre>
 */
class SCTPHeartbeatChunk : public ::inet::sctp::SCTPChunk
{
  protected:
    L3Address remoteAddr;
    ::omnetpp::simtime_t timeField;
    char *info; // array ptr
    unsigned int info_arraysize;

  private:
    void copy(const SCTPHeartbeatChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPHeartbeatChunk&);

  public:
    SCTPHeartbeatChunk(const char *name=nullptr, short kind=0);
    SCTPHeartbeatChunk(const SCTPHeartbeatChunk& other);
    virtual ~SCTPHeartbeatChunk();
    SCTPHeartbeatChunk& operator=(const SCTPHeartbeatChunk& other);
    virtual SCTPHeartbeatChunk *dup() const override {return new SCTPHeartbeatChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual L3Address& getRemoteAddr();
    virtual const L3Address& getRemoteAddr() const {return const_cast<SCTPHeartbeatChunk*>(this)->getRemoteAddr();}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual ::omnetpp::simtime_t getTimeField() const;
    virtual void setTimeField(::omnetpp::simtime_t timeField);
    virtual void setInfoArraySize(unsigned int size);
    virtual unsigned int getInfoArraySize() const;
    virtual char getInfo(unsigned int k) const;
    virtual void setInfo(unsigned int k, char info);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPHeartbeatChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPHeartbeatChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:215</tt> by nedtool.
 * <pre>
 * message SCTPHeartbeatAckChunk extends SCTPChunk
 * {
 *     L3Address remoteAddr;
 *     simtime_t timeField;
 *     char info[];
 * }
 * </pre>
 */
class SCTPHeartbeatAckChunk : public ::inet::sctp::SCTPChunk
{
  protected:
    L3Address remoteAddr;
    ::omnetpp::simtime_t timeField;
    char *info; // array ptr
    unsigned int info_arraysize;

  private:
    void copy(const SCTPHeartbeatAckChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPHeartbeatAckChunk&);

  public:
    SCTPHeartbeatAckChunk(const char *name=nullptr, short kind=0);
    SCTPHeartbeatAckChunk(const SCTPHeartbeatAckChunk& other);
    virtual ~SCTPHeartbeatAckChunk();
    SCTPHeartbeatAckChunk& operator=(const SCTPHeartbeatAckChunk& other);
    virtual SCTPHeartbeatAckChunk *dup() const override {return new SCTPHeartbeatAckChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual L3Address& getRemoteAddr();
    virtual const L3Address& getRemoteAddr() const {return const_cast<SCTPHeartbeatAckChunk*>(this)->getRemoteAddr();}
    virtual void setRemoteAddr(const L3Address& remoteAddr);
    virtual ::omnetpp::simtime_t getTimeField() const;
    virtual void setTimeField(::omnetpp::simtime_t timeField);
    virtual void setInfoArraySize(unsigned int size);
    virtual unsigned int getInfoArraySize() const;
    virtual char getInfo(unsigned int k) const;
    virtual void setInfo(unsigned int k, char info);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPHeartbeatAckChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPHeartbeatAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:222</tt> by nedtool.
 * <pre>
 * message SCTPShutdownChunk extends SCTPChunk
 * {
 *     uint32 cumTsnAck;
 * }
 * </pre>
 */
class SCTPShutdownChunk : public ::inet::sctp::SCTPChunk
{
  protected:
    uint32_t cumTsnAck;

  private:
    void copy(const SCTPShutdownChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPShutdownChunk&);

  public:
    SCTPShutdownChunk(const char *name=nullptr, short kind=0);
    SCTPShutdownChunk(const SCTPShutdownChunk& other);
    virtual ~SCTPShutdownChunk();
    SCTPShutdownChunk& operator=(const SCTPShutdownChunk& other);
    virtual SCTPShutdownChunk *dup() const override {return new SCTPShutdownChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getCumTsnAck() const;
    virtual void setCumTsnAck(uint32_t cumTsnAck);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPShutdownChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPShutdownChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:227</tt> by nedtool.
 * <pre>
 * message SCTPShutdownAckChunk extends SCTPChunk
 * {
 * }
 * </pre>
 */
class SCTPShutdownAckChunk : public ::inet::sctp::SCTPChunk
{
  protected:

  private:
    void copy(const SCTPShutdownAckChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPShutdownAckChunk&);

  public:
    SCTPShutdownAckChunk(const char *name=nullptr, short kind=0);
    SCTPShutdownAckChunk(const SCTPShutdownAckChunk& other);
    virtual ~SCTPShutdownAckChunk();
    SCTPShutdownAckChunk& operator=(const SCTPShutdownAckChunk& other);
    virtual SCTPShutdownAckChunk *dup() const override {return new SCTPShutdownAckChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPShutdownAckChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPShutdownAckChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:231</tt> by nedtool.
 * <pre>
 * message SCTPShutdownCompleteChunk extends SCTPChunk
 * {
 *     bool TBit = 0;
 * }
 * </pre>
 */
class SCTPShutdownCompleteChunk : public ::inet::sctp::SCTPChunk
{
  protected:
    bool TBit;

  private:
    void copy(const SCTPShutdownCompleteChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPShutdownCompleteChunk&);

  public:
    SCTPShutdownCompleteChunk(const char *name=nullptr, short kind=0);
    SCTPShutdownCompleteChunk(const SCTPShutdownCompleteChunk& other);
    virtual ~SCTPShutdownCompleteChunk();
    SCTPShutdownCompleteChunk& operator=(const SCTPShutdownCompleteChunk& other);
    virtual SCTPShutdownCompleteChunk *dup() const override {return new SCTPShutdownCompleteChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getTBit() const;
    virtual void setTBit(bool TBit);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPShutdownCompleteChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPShutdownCompleteChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:236</tt> by nedtool.
 * <pre>
 * message SCTPErrorChunk extends SCTPChunk
 * {
 *     \@customize(true);
 *     bool TBit = 0;
 *     bool MBit = 0;
 *     abstract cPacketPtr parameters[];
 * }
 * </pre>
 *
 * SCTPErrorChunk_Base is only useful if it gets subclassed, and SCTPErrorChunk is derived from it.
 * The minimum code to be written for SCTPErrorChunk is the following:
 *
 * <pre>
 * class SCTPErrorChunk : public SCTPErrorChunk_Base
 * {
 *   private:
 *     void copy(const SCTPErrorChunk& other) { ... }

 *   public:
 *     SCTPErrorChunk(const char *name=nullptr, short kind=0) : SCTPErrorChunk_Base(name,kind) {}
 *     SCTPErrorChunk(const SCTPErrorChunk& other) : SCTPErrorChunk_Base(other) {copy(other);}
 *     SCTPErrorChunk& operator=(const SCTPErrorChunk& other) {if (this==&other) return *this; SCTPErrorChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SCTPErrorChunk *dup() const override {return new SCTPErrorChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SCTPErrorChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SCTPErrorChunk)
 * </pre>
 */
class SCTPErrorChunk_Base : public ::inet::sctp::SCTPChunk
{
  protected:
    bool TBit;
    bool MBit;

  private:
    void copy(const SCTPErrorChunk_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPErrorChunk_Base&);
    // make constructors protected to avoid instantiation
    SCTPErrorChunk_Base(const char *name=nullptr, short kind=0);
    SCTPErrorChunk_Base(const SCTPErrorChunk_Base& other);
    // make assignment operator protected to force the user override it
    SCTPErrorChunk_Base& operator=(const SCTPErrorChunk_Base& other);

  public:
    virtual ~SCTPErrorChunk_Base();
    virtual SCTPErrorChunk_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SCTPErrorChunk");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getTBit() const;
    virtual void setTBit(bool TBit);
    virtual bool getMBit() const;
    virtual void setMBit(bool MBit);
    virtual void setParametersArraySize(unsigned int size) = 0;
    virtual unsigned int getParametersArraySize() const = 0;
    virtual cPacketPtr& getParameters(unsigned int k) = 0;
    virtual const cPacketPtr& getParameters(unsigned int k) const {return const_cast<SCTPErrorChunk_Base*>(this)->getParameters(k);}
    virtual void setParameters(unsigned int k, const cPacketPtr& parameters) = 0;
};

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:244</tt> by nedtool.
 * <pre>
 * message SCTPParameter extends cPacket
 * {
 *     uint16 parameterType;
 * }
 * </pre>
 */
class SCTPParameter : public ::omnetpp::cPacket
{
  protected:
    uint16_t parameterType;

  private:
    void copy(const SCTPParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPParameter&);

  public:
    SCTPParameter(const char *name=nullptr, short kind=0);
    SCTPParameter(const SCTPParameter& other);
    virtual ~SCTPParameter();
    SCTPParameter& operator=(const SCTPParameter& other);
    virtual SCTPParameter *dup() const override {return new SCTPParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getParameterType() const;
    virtual void setParameterType(uint16_t parameterType);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:249</tt> by nedtool.
 * <pre>
 * message SCTPPacketDropChunk extends SCTPChunk
 * {
 *     bool cFlag;
 *     bool tFlag;
 *     bool bFlag;
 *     bool mFlag;
 *     uint32 maxRwnd;
 *     uint32 queuedData;
 *     uint16 truncLength;
 * }
 * </pre>
 */
class SCTPPacketDropChunk : public ::inet::sctp::SCTPChunk
{
  protected:
    bool cFlag;
    bool tFlag;
    bool bFlag;
    bool mFlag;
    uint32_t maxRwnd;
    uint32_t queuedData;
    uint16_t truncLength;

  private:
    void copy(const SCTPPacketDropChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPPacketDropChunk&);

  public:
    SCTPPacketDropChunk(const char *name=nullptr, short kind=0);
    SCTPPacketDropChunk(const SCTPPacketDropChunk& other);
    virtual ~SCTPPacketDropChunk();
    SCTPPacketDropChunk& operator=(const SCTPPacketDropChunk& other);
    virtual SCTPPacketDropChunk *dup() const override {return new SCTPPacketDropChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getCFlag() const;
    virtual void setCFlag(bool cFlag);
    virtual bool getTFlag() const;
    virtual void setTFlag(bool tFlag);
    virtual bool getBFlag() const;
    virtual void setBFlag(bool bFlag);
    virtual bool getMFlag() const;
    virtual void setMFlag(bool mFlag);
    virtual uint32_t getMaxRwnd() const;
    virtual void setMaxRwnd(uint32_t maxRwnd);
    virtual uint32_t getQueuedData() const;
    virtual void setQueuedData(uint32_t queuedData);
    virtual uint16_t getTruncLength() const;
    virtual void setTruncLength(uint16_t truncLength);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPPacketDropChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPPacketDropChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:260</tt> by nedtool.
 * <pre>
 * message SCTPStreamResetChunk extends SCTPChunk
 * {
 *     \@customize(true);
 *     abstract cPacketPtr parameters[];
 * }
 * </pre>
 *
 * SCTPStreamResetChunk_Base is only useful if it gets subclassed, and SCTPStreamResetChunk is derived from it.
 * The minimum code to be written for SCTPStreamResetChunk is the following:
 *
 * <pre>
 * class SCTPStreamResetChunk : public SCTPStreamResetChunk_Base
 * {
 *   private:
 *     void copy(const SCTPStreamResetChunk& other) { ... }

 *   public:
 *     SCTPStreamResetChunk(const char *name=nullptr, short kind=0) : SCTPStreamResetChunk_Base(name,kind) {}
 *     SCTPStreamResetChunk(const SCTPStreamResetChunk& other) : SCTPStreamResetChunk_Base(other) {copy(other);}
 *     SCTPStreamResetChunk& operator=(const SCTPStreamResetChunk& other) {if (this==&other) return *this; SCTPStreamResetChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SCTPStreamResetChunk *dup() const override {return new SCTPStreamResetChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SCTPStreamResetChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SCTPStreamResetChunk)
 * </pre>
 */
class SCTPStreamResetChunk_Base : public ::inet::sctp::SCTPChunk
{
  protected:

  private:
    void copy(const SCTPStreamResetChunk_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPStreamResetChunk_Base&);
    // make constructors protected to avoid instantiation
    SCTPStreamResetChunk_Base(const char *name=nullptr, short kind=0);
    SCTPStreamResetChunk_Base(const SCTPStreamResetChunk_Base& other);
    // make assignment operator protected to force the user override it
    SCTPStreamResetChunk_Base& operator=(const SCTPStreamResetChunk_Base& other);

  public:
    virtual ~SCTPStreamResetChunk_Base();
    virtual SCTPStreamResetChunk_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SCTPStreamResetChunk");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setParametersArraySize(unsigned int size) = 0;
    virtual unsigned int getParametersArraySize() const = 0;
    virtual cPacketPtr& getParameters(unsigned int k) = 0;
    virtual const cPacketPtr& getParameters(unsigned int k) const {return const_cast<SCTPStreamResetChunk_Base*>(this)->getParameters(k);}
    virtual void setParameters(unsigned int k, const cPacketPtr& parameters) = 0;
};

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:266</tt> by nedtool.
 * <pre>
 * message SCTPOutgoingSSNResetRequestParameter extends SCTPParameter
 * {
 *     uint32 srReqSn; //Stream Reset Request Sequence Number: initialized with the initial TSN, then incremented
 *     uint32 srResSn; //Stream Reset Response Sequence Number
 *     uint32 lastTsn; //Senders last assigned TSN
 *     uint16 streamNumbers[];
 * }
 * </pre>
 */
class SCTPOutgoingSSNResetRequestParameter : public ::inet::sctp::SCTPParameter
{
  protected:
    uint32_t srReqSn;
    uint32_t srResSn;
    uint32_t lastTsn;
    uint16_t *streamNumbers; // array ptr
    unsigned int streamNumbers_arraysize;

  private:
    void copy(const SCTPOutgoingSSNResetRequestParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPOutgoingSSNResetRequestParameter&);

  public:
    SCTPOutgoingSSNResetRequestParameter(const char *name=nullptr, short kind=0);
    SCTPOutgoingSSNResetRequestParameter(const SCTPOutgoingSSNResetRequestParameter& other);
    virtual ~SCTPOutgoingSSNResetRequestParameter();
    SCTPOutgoingSSNResetRequestParameter& operator=(const SCTPOutgoingSSNResetRequestParameter& other);
    virtual SCTPOutgoingSSNResetRequestParameter *dup() const override {return new SCTPOutgoingSSNResetRequestParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSrReqSn() const;
    virtual void setSrReqSn(uint32_t srReqSn);
    virtual uint32_t getSrResSn() const;
    virtual void setSrResSn(uint32_t srResSn);
    virtual uint32_t getLastTsn() const;
    virtual void setLastTsn(uint32_t lastTsn);
    virtual void setStreamNumbersArraySize(unsigned int size);
    virtual unsigned int getStreamNumbersArraySize() const;
    virtual uint16_t getStreamNumbers(unsigned int k) const;
    virtual void setStreamNumbers(unsigned int k, uint16_t streamNumbers);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPOutgoingSSNResetRequestParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPOutgoingSSNResetRequestParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:274</tt> by nedtool.
 * <pre>
 * message SCTPIncomingSSNResetRequestParameter extends SCTPParameter
 * {
 *     \@customize(true);
 *     uint32 srReqSn; //Stream Reset Request Sequence Number
 *     uint16 streamNumbers[];
 * }
 * </pre>
 *
 * SCTPIncomingSSNResetRequestParameter_Base is only useful if it gets subclassed, and SCTPIncomingSSNResetRequestParameter is derived from it.
 * The minimum code to be written for SCTPIncomingSSNResetRequestParameter is the following:
 *
 * <pre>
 * class SCTPIncomingSSNResetRequestParameter : public SCTPIncomingSSNResetRequestParameter_Base
 * {
 *   private:
 *     void copy(const SCTPIncomingSSNResetRequestParameter& other) { ... }

 *   public:
 *     SCTPIncomingSSNResetRequestParameter(const char *name=nullptr, short kind=0) : SCTPIncomingSSNResetRequestParameter_Base(name,kind) {}
 *     SCTPIncomingSSNResetRequestParameter(const SCTPIncomingSSNResetRequestParameter& other) : SCTPIncomingSSNResetRequestParameter_Base(other) {copy(other);}
 *     SCTPIncomingSSNResetRequestParameter& operator=(const SCTPIncomingSSNResetRequestParameter& other) {if (this==&other) return *this; SCTPIncomingSSNResetRequestParameter_Base::operator=(other); copy(other); return *this;}
 *     virtual SCTPIncomingSSNResetRequestParameter *dup() const override {return new SCTPIncomingSSNResetRequestParameter(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SCTPIncomingSSNResetRequestParameter_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SCTPIncomingSSNResetRequestParameter)
 * </pre>
 */
class SCTPIncomingSSNResetRequestParameter_Base : public ::inet::sctp::SCTPParameter
{
  protected:
    uint32_t srReqSn;
    uint16_t *streamNumbers; // array ptr
    unsigned int streamNumbers_arraysize;

  private:
    void copy(const SCTPIncomingSSNResetRequestParameter_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPIncomingSSNResetRequestParameter_Base&);
    // make constructors protected to avoid instantiation
    SCTPIncomingSSNResetRequestParameter_Base(const char *name=nullptr, short kind=0);
    SCTPIncomingSSNResetRequestParameter_Base(const SCTPIncomingSSNResetRequestParameter_Base& other);
    // make assignment operator protected to force the user override it
    SCTPIncomingSSNResetRequestParameter_Base& operator=(const SCTPIncomingSSNResetRequestParameter_Base& other);

  public:
    virtual ~SCTPIncomingSSNResetRequestParameter_Base();
    virtual SCTPIncomingSSNResetRequestParameter_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SCTPIncomingSSNResetRequestParameter");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSrReqSn() const;
    virtual void setSrReqSn(uint32_t srReqSn);
    virtual void setStreamNumbersArraySize(unsigned int size);
    virtual unsigned int getStreamNumbersArraySize() const;
    virtual uint16_t getStreamNumbers(unsigned int k) const;
    virtual void setStreamNumbers(unsigned int k, uint16_t streamNumbers);
};

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:281</tt> by nedtool.
 * <pre>
 * message SCTPSSNTSNResetRequestParameter extends SCTPParameter
 * {
 *     uint32 srReqSn; //Stream Reset Request Sequence Number
 * }
 * </pre>
 */
class SCTPSSNTSNResetRequestParameter : public ::inet::sctp::SCTPParameter
{
  protected:
    uint32_t srReqSn;

  private:
    void copy(const SCTPSSNTSNResetRequestParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPSSNTSNResetRequestParameter&);

  public:
    SCTPSSNTSNResetRequestParameter(const char *name=nullptr, short kind=0);
    SCTPSSNTSNResetRequestParameter(const SCTPSSNTSNResetRequestParameter& other);
    virtual ~SCTPSSNTSNResetRequestParameter();
    SCTPSSNTSNResetRequestParameter& operator=(const SCTPSSNTSNResetRequestParameter& other);
    virtual SCTPSSNTSNResetRequestParameter *dup() const override {return new SCTPSSNTSNResetRequestParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSrReqSn() const;
    virtual void setSrReqSn(uint32_t srReqSn);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPSSNTSNResetRequestParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPSSNTSNResetRequestParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:286</tt> by nedtool.
 * <pre>
 * message SCTPStreamResetResponseParameter extends SCTPParameter
 * {
 *     uint32 srResSn; //Stream Reset Response Sequence Number
 *     uint32 result;
 *     uint32 sendersNextTsn = 0;
 *     uint32 receiversNextTsn = 0;
 * }
 * </pre>
 */
class SCTPStreamResetResponseParameter : public ::inet::sctp::SCTPParameter
{
  protected:
    uint32_t srResSn;
    uint32_t result;
    uint32_t sendersNextTsn;
    uint32_t receiversNextTsn;

  private:
    void copy(const SCTPStreamResetResponseParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPStreamResetResponseParameter&);

  public:
    SCTPStreamResetResponseParameter(const char *name=nullptr, short kind=0);
    SCTPStreamResetResponseParameter(const SCTPStreamResetResponseParameter& other);
    virtual ~SCTPStreamResetResponseParameter();
    SCTPStreamResetResponseParameter& operator=(const SCTPStreamResetResponseParameter& other);
    virtual SCTPStreamResetResponseParameter *dup() const override {return new SCTPStreamResetResponseParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSrResSn() const;
    virtual void setSrResSn(uint32_t srResSn);
    virtual uint32_t getResult() const;
    virtual void setResult(uint32_t result);
    virtual uint32_t getSendersNextTsn() const;
    virtual void setSendersNextTsn(uint32_t sendersNextTsn);
    virtual uint32_t getReceiversNextTsn() const;
    virtual void setReceiversNextTsn(uint32_t receiversNextTsn);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPStreamResetResponseParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPStreamResetResponseParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:294</tt> by nedtool.
 * <pre>
 * message SCTPAddStreamsRequestParameter extends SCTPParameter
 * {
 *     uint32 srReqSn; //Stream Reset Request Sequence Number
 *     uint16 numberOfStreams;
 *     uint16 reserved = 0;
 * }
 * </pre>
 */
class SCTPAddStreamsRequestParameter : public ::inet::sctp::SCTPParameter
{
  protected:
    uint32_t srReqSn;
    uint16_t numberOfStreams;
    uint16_t reserved;

  private:
    void copy(const SCTPAddStreamsRequestParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPAddStreamsRequestParameter&);

  public:
    SCTPAddStreamsRequestParameter(const char *name=nullptr, short kind=0);
    SCTPAddStreamsRequestParameter(const SCTPAddStreamsRequestParameter& other);
    virtual ~SCTPAddStreamsRequestParameter();
    SCTPAddStreamsRequestParameter& operator=(const SCTPAddStreamsRequestParameter& other);
    virtual SCTPAddStreamsRequestParameter *dup() const override {return new SCTPAddStreamsRequestParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSrReqSn() const;
    virtual void setSrReqSn(uint32_t srReqSn);
    virtual uint16_t getNumberOfStreams() const;
    virtual void setNumberOfStreams(uint16_t numberOfStreams);
    virtual uint16_t getReserved() const;
    virtual void setReserved(uint16_t reserved);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPAddStreamsRequestParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPAddStreamsRequestParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:301</tt> by nedtool.
 * <pre>
 * message SCTPResetTimer extends cPacket
 * {
 *     uint32 inSN; //Stream Reset Response Sequence Number for Incoming Reset Request
 *     bool inAcked;   // false, when timer is running for the Reset Response Sequence Number, true otherwise
 *     uint32 outSN; //Stream Reset Response Sequence Number for Outgoing Reset Request
 *     bool outAcked;
 * }
 * </pre>
 */
class SCTPResetTimer : public ::omnetpp::cPacket
{
  protected:
    uint32_t inSN;
    bool inAcked;
    uint32_t outSN;
    bool outAcked;

  private:
    void copy(const SCTPResetTimer& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPResetTimer&);

  public:
    SCTPResetTimer(const char *name=nullptr, short kind=0);
    SCTPResetTimer(const SCTPResetTimer& other);
    virtual ~SCTPResetTimer();
    SCTPResetTimer& operator=(const SCTPResetTimer& other);
    virtual SCTPResetTimer *dup() const override {return new SCTPResetTimer(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getInSN() const;
    virtual void setInSN(uint32_t inSN);
    virtual bool getInAcked() const;
    virtual void setInAcked(bool inAcked);
    virtual uint32_t getOutSN() const;
    virtual void setOutSN(uint32_t outSN);
    virtual bool getOutAcked() const;
    virtual void setOutAcked(bool outAcked);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPResetTimer& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPResetTimer& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:309</tt> by nedtool.
 * <pre>
 * message SCTPAuthenticationChunk extends SCTPChunk
 * {
 *     uint16 sharedKey;
 *     uint16 hMacIdentifier;
 *     bool hMacOk;
 *     uint32 HMAC[];
 * }
 * </pre>
 */
class SCTPAuthenticationChunk : public ::inet::sctp::SCTPChunk
{
  protected:
    uint16_t sharedKey;
    uint16_t hMacIdentifier;
    bool hMacOk;
    uint32_t *HMAC; // array ptr
    unsigned int HMAC_arraysize;

  private:
    void copy(const SCTPAuthenticationChunk& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPAuthenticationChunk&);

  public:
    SCTPAuthenticationChunk(const char *name=nullptr, short kind=0);
    SCTPAuthenticationChunk(const SCTPAuthenticationChunk& other);
    virtual ~SCTPAuthenticationChunk();
    SCTPAuthenticationChunk& operator=(const SCTPAuthenticationChunk& other);
    virtual SCTPAuthenticationChunk *dup() const override {return new SCTPAuthenticationChunk(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getSharedKey() const;
    virtual void setSharedKey(uint16_t sharedKey);
    virtual uint16_t getHMacIdentifier() const;
    virtual void setHMacIdentifier(uint16_t hMacIdentifier);
    virtual bool getHMacOk() const;
    virtual void setHMacOk(bool hMacOk);
    virtual void setHMACArraySize(unsigned int size);
    virtual unsigned int getHMACArraySize() const;
    virtual uint32_t getHMAC(unsigned int k) const;
    virtual void setHMAC(unsigned int k, uint32_t HMAC);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPAuthenticationChunk& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPAuthenticationChunk& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:317</tt> by nedtool.
 * <pre>
 * message SCTPAsconfChunk extends SCTPChunk
 * {
 *     \@customize(true);
 *     uint32 serialNumber;
 *     L3Address addressParam;
 *     uint32 peerVTag; //for NAT
 *     abstract cPacketPtr asconfParams[];
 * }
 * </pre>
 *
 * SCTPAsconfChunk_Base is only useful if it gets subclassed, and SCTPAsconfChunk is derived from it.
 * The minimum code to be written for SCTPAsconfChunk is the following:
 *
 * <pre>
 * class SCTPAsconfChunk : public SCTPAsconfChunk_Base
 * {
 *   private:
 *     void copy(const SCTPAsconfChunk& other) { ... }

 *   public:
 *     SCTPAsconfChunk(const char *name=nullptr, short kind=0) : SCTPAsconfChunk_Base(name,kind) {}
 *     SCTPAsconfChunk(const SCTPAsconfChunk& other) : SCTPAsconfChunk_Base(other) {copy(other);}
 *     SCTPAsconfChunk& operator=(const SCTPAsconfChunk& other) {if (this==&other) return *this; SCTPAsconfChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SCTPAsconfChunk *dup() const override {return new SCTPAsconfChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SCTPAsconfChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SCTPAsconfChunk)
 * </pre>
 */
class SCTPAsconfChunk_Base : public ::inet::sctp::SCTPChunk
{
  protected:
    uint32_t serialNumber;
    L3Address addressParam;
    uint32_t peerVTag;

  private:
    void copy(const SCTPAsconfChunk_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPAsconfChunk_Base&);
    // make constructors protected to avoid instantiation
    SCTPAsconfChunk_Base(const char *name=nullptr, short kind=0);
    SCTPAsconfChunk_Base(const SCTPAsconfChunk_Base& other);
    // make assignment operator protected to force the user override it
    SCTPAsconfChunk_Base& operator=(const SCTPAsconfChunk_Base& other);

  public:
    virtual ~SCTPAsconfChunk_Base();
    virtual SCTPAsconfChunk_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SCTPAsconfChunk");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSerialNumber() const;
    virtual void setSerialNumber(uint32_t serialNumber);
    virtual L3Address& getAddressParam();
    virtual const L3Address& getAddressParam() const {return const_cast<SCTPAsconfChunk_Base*>(this)->getAddressParam();}
    virtual void setAddressParam(const L3Address& addressParam);
    virtual uint32_t getPeerVTag() const;
    virtual void setPeerVTag(uint32_t peerVTag);
    virtual void setAsconfParamsArraySize(unsigned int size) = 0;
    virtual unsigned int getAsconfParamsArraySize() const = 0;
    virtual cPacketPtr& getAsconfParams(unsigned int k) = 0;
    virtual const cPacketPtr& getAsconfParams(unsigned int k) const {return const_cast<SCTPAsconfChunk_Base*>(this)->getAsconfParams(k);}
    virtual void setAsconfParams(unsigned int k, const cPacketPtr& asconfParams) = 0;
};

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:326</tt> by nedtool.
 * <pre>
 * message SCTPAsconfAckChunk extends SCTPChunk
 * {
 *     \@customize(true);
 *     uint32 serialNumber;
 *     abstract cPacketPtr asconfResponse[];
 * }
 * </pre>
 *
 * SCTPAsconfAckChunk_Base is only useful if it gets subclassed, and SCTPAsconfAckChunk is derived from it.
 * The minimum code to be written for SCTPAsconfAckChunk is the following:
 *
 * <pre>
 * class SCTPAsconfAckChunk : public SCTPAsconfAckChunk_Base
 * {
 *   private:
 *     void copy(const SCTPAsconfAckChunk& other) { ... }

 *   public:
 *     SCTPAsconfAckChunk(const char *name=nullptr, short kind=0) : SCTPAsconfAckChunk_Base(name,kind) {}
 *     SCTPAsconfAckChunk(const SCTPAsconfAckChunk& other) : SCTPAsconfAckChunk_Base(other) {copy(other);}
 *     SCTPAsconfAckChunk& operator=(const SCTPAsconfAckChunk& other) {if (this==&other) return *this; SCTPAsconfAckChunk_Base::operator=(other); copy(other); return *this;}
 *     virtual SCTPAsconfAckChunk *dup() const override {return new SCTPAsconfAckChunk(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from SCTPAsconfAckChunk_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(SCTPAsconfAckChunk)
 * </pre>
 */
class SCTPAsconfAckChunk_Base : public ::inet::sctp::SCTPChunk
{
  protected:
    uint32_t serialNumber;

  private:
    void copy(const SCTPAsconfAckChunk_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPAsconfAckChunk_Base&);
    // make constructors protected to avoid instantiation
    SCTPAsconfAckChunk_Base(const char *name=nullptr, short kind=0);
    SCTPAsconfAckChunk_Base(const SCTPAsconfAckChunk_Base& other);
    // make assignment operator protected to force the user override it
    SCTPAsconfAckChunk_Base& operator=(const SCTPAsconfAckChunk_Base& other);

  public:
    virtual ~SCTPAsconfAckChunk_Base();
    virtual SCTPAsconfAckChunk_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class SCTPAsconfAckChunk");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSerialNumber() const;
    virtual void setSerialNumber(uint32_t serialNumber);
    virtual void setAsconfResponseArraySize(unsigned int size) = 0;
    virtual unsigned int getAsconfResponseArraySize() const = 0;
    virtual cPacketPtr& getAsconfResponse(unsigned int k) = 0;
    virtual const cPacketPtr& getAsconfResponse(unsigned int k) const {return const_cast<SCTPAsconfAckChunk_Base*>(this)->getAsconfResponse(k);}
    virtual void setAsconfResponse(unsigned int k, const cPacketPtr& asconfResponse) = 0;
};

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:333</tt> by nedtool.
 * <pre>
 * message SCTPAddIPParameter extends SCTPParameter
 * {
 *     uint32 requestCorrelationId; //assigned by the sender to identify each request parameter
 *     L3Address addressParam;
 * }
 * </pre>
 */
class SCTPAddIPParameter : public ::inet::sctp::SCTPParameter
{
  protected:
    uint32_t requestCorrelationId;
    L3Address addressParam;

  private:
    void copy(const SCTPAddIPParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPAddIPParameter&);

  public:
    SCTPAddIPParameter(const char *name=nullptr, short kind=0);
    SCTPAddIPParameter(const SCTPAddIPParameter& other);
    virtual ~SCTPAddIPParameter();
    SCTPAddIPParameter& operator=(const SCTPAddIPParameter& other);
    virtual SCTPAddIPParameter *dup() const override {return new SCTPAddIPParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getRequestCorrelationId() const;
    virtual void setRequestCorrelationId(uint32_t requestCorrelationId);
    virtual L3Address& getAddressParam();
    virtual const L3Address& getAddressParam() const {return const_cast<SCTPAddIPParameter*>(this)->getAddressParam();}
    virtual void setAddressParam(const L3Address& addressParam);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPAddIPParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPAddIPParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:339</tt> by nedtool.
 * <pre>
 * message SCTPDeleteIPParameter extends SCTPParameter
 * {
 *     uint32 requestCorrelationId; //assigned by the sender to identify each request parameter
 *     L3Address addressParam;
 * }
 * </pre>
 */
class SCTPDeleteIPParameter : public ::inet::sctp::SCTPParameter
{
  protected:
    uint32_t requestCorrelationId;
    L3Address addressParam;

  private:
    void copy(const SCTPDeleteIPParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPDeleteIPParameter&);

  public:
    SCTPDeleteIPParameter(const char *name=nullptr, short kind=0);
    SCTPDeleteIPParameter(const SCTPDeleteIPParameter& other);
    virtual ~SCTPDeleteIPParameter();
    SCTPDeleteIPParameter& operator=(const SCTPDeleteIPParameter& other);
    virtual SCTPDeleteIPParameter *dup() const override {return new SCTPDeleteIPParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getRequestCorrelationId() const;
    virtual void setRequestCorrelationId(uint32_t requestCorrelationId);
    virtual L3Address& getAddressParam();
    virtual const L3Address& getAddressParam() const {return const_cast<SCTPDeleteIPParameter*>(this)->getAddressParam();}
    virtual void setAddressParam(const L3Address& addressParam);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPDeleteIPParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPDeleteIPParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:345</tt> by nedtool.
 * <pre>
 * message SCTPSetPrimaryIPParameter extends SCTPParameter
 * {
 *     uint32 requestCorrelationId; //assigned by the sender to identify each request parameter
 *     L3Address addressParam;
 * }
 * </pre>
 */
class SCTPSetPrimaryIPParameter : public ::inet::sctp::SCTPParameter
{
  protected:
    uint32_t requestCorrelationId;
    L3Address addressParam;

  private:
    void copy(const SCTPSetPrimaryIPParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPSetPrimaryIPParameter&);

  public:
    SCTPSetPrimaryIPParameter(const char *name=nullptr, short kind=0);
    SCTPSetPrimaryIPParameter(const SCTPSetPrimaryIPParameter& other);
    virtual ~SCTPSetPrimaryIPParameter();
    SCTPSetPrimaryIPParameter& operator=(const SCTPSetPrimaryIPParameter& other);
    virtual SCTPSetPrimaryIPParameter *dup() const override {return new SCTPSetPrimaryIPParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getRequestCorrelationId() const;
    virtual void setRequestCorrelationId(uint32_t requestCorrelationId);
    virtual L3Address& getAddressParam();
    virtual const L3Address& getAddressParam() const {return const_cast<SCTPSetPrimaryIPParameter*>(this)->getAddressParam();}
    virtual void setAddressParam(const L3Address& addressParam);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPSetPrimaryIPParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPSetPrimaryIPParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:351</tt> by nedtool.
 * <pre>
 * message SCTPSupportedExtensionsParameter extends SCTPParameter
 * {
 *     uint16 chunkTypes[];
 * }
 * </pre>
 */
class SCTPSupportedExtensionsParameter : public ::inet::sctp::SCTPParameter
{
  protected:
    uint16_t *chunkTypes; // array ptr
    unsigned int chunkTypes_arraysize;

  private:
    void copy(const SCTPSupportedExtensionsParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPSupportedExtensionsParameter&);

  public:
    SCTPSupportedExtensionsParameter(const char *name=nullptr, short kind=0);
    SCTPSupportedExtensionsParameter(const SCTPSupportedExtensionsParameter& other);
    virtual ~SCTPSupportedExtensionsParameter();
    SCTPSupportedExtensionsParameter& operator=(const SCTPSupportedExtensionsParameter& other);
    virtual SCTPSupportedExtensionsParameter *dup() const override {return new SCTPSupportedExtensionsParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setChunkTypesArraySize(unsigned int size);
    virtual unsigned int getChunkTypesArraySize() const;
    virtual uint16_t getChunkTypes(unsigned int k) const;
    virtual void setChunkTypes(unsigned int k, uint16_t chunkTypes);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPSupportedExtensionsParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPSupportedExtensionsParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:356</tt> by nedtool.
 * <pre>
 * message SCTPErrorCauseParameter extends SCTPParameter
 * {
 *     uint32 responseCorrelationId;
 *     uint32 errorCauseType;
 * }
 * </pre>
 */
class SCTPErrorCauseParameter : public ::inet::sctp::SCTPParameter
{
  protected:
    uint32_t responseCorrelationId;
    uint32_t errorCauseType;

  private:
    void copy(const SCTPErrorCauseParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPErrorCauseParameter&);

  public:
    SCTPErrorCauseParameter(const char *name=nullptr, short kind=0);
    SCTPErrorCauseParameter(const SCTPErrorCauseParameter& other);
    virtual ~SCTPErrorCauseParameter();
    SCTPErrorCauseParameter& operator=(const SCTPErrorCauseParameter& other);
    virtual SCTPErrorCauseParameter *dup() const override {return new SCTPErrorCauseParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getResponseCorrelationId() const;
    virtual void setResponseCorrelationId(uint32_t responseCorrelationId);
    virtual uint32_t getErrorCauseType() const;
    virtual void setErrorCauseType(uint32_t errorCauseType);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPErrorCauseParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPErrorCauseParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:362</tt> by nedtool.
 * <pre>
 * message SCTPSimpleErrorCauseParameter extends SCTPParameter
 * {
 *     uint16 value;
 * }
 * </pre>
 */
class SCTPSimpleErrorCauseParameter : public ::inet::sctp::SCTPParameter
{
  protected:
    uint16_t value;

  private:
    void copy(const SCTPSimpleErrorCauseParameter& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPSimpleErrorCauseParameter&);

  public:
    SCTPSimpleErrorCauseParameter(const char *name=nullptr, short kind=0);
    SCTPSimpleErrorCauseParameter(const SCTPSimpleErrorCauseParameter& other);
    virtual ~SCTPSimpleErrorCauseParameter();
    SCTPSimpleErrorCauseParameter& operator=(const SCTPSimpleErrorCauseParameter& other);
    virtual SCTPSimpleErrorCauseParameter *dup() const override {return new SCTPSimpleErrorCauseParameter(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint16_t getValue() const;
    virtual void setValue(uint16_t value);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPSimpleErrorCauseParameter& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPSimpleErrorCauseParameter& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:367</tt> by nedtool.
 * <pre>
 * message SCTPSuccessIndication extends SCTPParameter
 * {
 *     uint32 responseCorrelationId;
 * }
 * </pre>
 */
class SCTPSuccessIndication : public ::inet::sctp::SCTPParameter
{
  protected:
    uint32_t responseCorrelationId;

  private:
    void copy(const SCTPSuccessIndication& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SCTPSuccessIndication&);

  public:
    SCTPSuccessIndication(const char *name=nullptr, short kind=0);
    SCTPSuccessIndication(const SCTPSuccessIndication& other);
    virtual ~SCTPSuccessIndication();
    SCTPSuccessIndication& operator=(const SCTPSuccessIndication& other);
    virtual SCTPSuccessIndication *dup() const override {return new SCTPSuccessIndication(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getResponseCorrelationId() const;
    virtual void setResponseCorrelationId(uint32_t responseCorrelationId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SCTPSuccessIndication& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SCTPSuccessIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/sctp/SCTPMessage.msg:372</tt> by nedtool.
 * <pre>
 * message NatMessage extends cPacket
 * {
 *     bool multi;
 *     uint16 peer1;
 *     L3Address peer1Addresses[];
 *     uint32 portPeer1;
 *     uint16 peer2;
 *     L3Address peer2Addresses[];
 *     uint32 portPeer2;
 * }
 * </pre>
 */
class NatMessage : public ::omnetpp::cPacket
{
  protected:
    bool multi;
    uint16_t peer1;
    L3Address *peer1Addresses; // array ptr
    unsigned int peer1Addresses_arraysize;
    uint32_t portPeer1;
    uint16_t peer2;
    L3Address *peer2Addresses; // array ptr
    unsigned int peer2Addresses_arraysize;
    uint32_t portPeer2;

  private:
    void copy(const NatMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const NatMessage&);

  public:
    NatMessage(const char *name=nullptr, short kind=0);
    NatMessage(const NatMessage& other);
    virtual ~NatMessage();
    NatMessage& operator=(const NatMessage& other);
    virtual NatMessage *dup() const override {return new NatMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getMulti() const;
    virtual void setMulti(bool multi);
    virtual uint16_t getPeer1() const;
    virtual void setPeer1(uint16_t peer1);
    virtual void setPeer1AddressesArraySize(unsigned int size);
    virtual unsigned int getPeer1AddressesArraySize() const;
    virtual L3Address& getPeer1Addresses(unsigned int k);
    virtual const L3Address& getPeer1Addresses(unsigned int k) const {return const_cast<NatMessage*>(this)->getPeer1Addresses(k);}
    virtual void setPeer1Addresses(unsigned int k, const L3Address& peer1Addresses);
    virtual uint32_t getPortPeer1() const;
    virtual void setPortPeer1(uint32_t portPeer1);
    virtual uint16_t getPeer2() const;
    virtual void setPeer2(uint16_t peer2);
    virtual void setPeer2AddressesArraySize(unsigned int size);
    virtual unsigned int getPeer2AddressesArraySize() const;
    virtual L3Address& getPeer2Addresses(unsigned int k);
    virtual const L3Address& getPeer2Addresses(unsigned int k) const {return const_cast<NatMessage*>(this)->getPeer2Addresses(k);}
    virtual void setPeer2Addresses(unsigned int k, const L3Address& peer2Addresses);
    virtual uint32_t getPortPeer2() const;
    virtual void setPortPeer2(uint32_t portPeer2);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NatMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NatMessage& obj) {obj.parsimUnpack(b);}

} // namespace sctp
} // namespace inet

#endif // ifndef __INET__SCTP_SCTPMESSAGE_M_H

