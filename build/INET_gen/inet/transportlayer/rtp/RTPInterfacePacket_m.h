//
// Generated file, do not edit! Created by nedtool 5.7 from /home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg.
//

#ifndef __INET__RTP_RTPINTERFACEPACKET_M_H
#define __INET__RTP_RTPINTERFACEPACKET_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0507
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
#include "inet/common/INETDefs.h"
#include "inet/networklayer/contract/ipv4/IPv4Address.h"
#include "inet/transportlayer/rtp/RTPSenderControlMessage_m.h"
#include "inet/transportlayer/rtp/RTPSenderStatusMessage_m.h"
// }}


namespace inet {
namespace rtp {

/**
 * Enum generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg:40</tt> by nedtool.
 * <pre>
 * //
 * // An enumeration to distinguish the different functions of the
 * // RTPInterfacePacket.
 * //
 * enum RTP_IFP_TYPE
 * {
 *     RTP_IFP_ENTER_SESSION = 1;
 *     RTP_IFP_SESSION_ENTERED = 2;
 *     RTP_IFP_CREATE_SENDER_MODULE = 3;
 *     RTP_IFP_SENDER_MODULE_CREATED = 4;
 *     RTP_IFP_DELETE_SENDER_MODULE = 5;
 *     RTP_IFP_SENDER_MODULE_DELETED = 6;
 *     RTP_IFP_SENDER_CONTROL = 7;
 *     RTP_IFP_SENDER_STATUS = 8;
 *     RTP_IFP_LEAVE_SESSION = 9;
 *     RTP_IFP_SESSION_LEFT = 10;
 * }
 * 
 * //
 * // The next classes are used for communication between an ~RTPApplication
 * // and an RTPLayer module. Its offers functionality for starting and stopping of an
 * // rtp session, transmission of files and feedback about the success of the
 * // operations.
 * </pre>
 */
enum RTP_IFP_TYPE {
    RTP_IFP_ENTER_SESSION = 1,
    RTP_IFP_SESSION_ENTERED = 2,
    RTP_IFP_CREATE_SENDER_MODULE = 3,
    RTP_IFP_SENDER_MODULE_CREATED = 4,
    RTP_IFP_DELETE_SENDER_MODULE = 5,
    RTP_IFP_SENDER_MODULE_DELETED = 6,
    RTP_IFP_SENDER_CONTROL = 7,
    RTP_IFP_SENDER_STATUS = 8,
    RTP_IFP_LEAVE_SESSION = 9,
    RTP_IFP_SESSION_LEFT = 10
};

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg:60</tt> by nedtool.
 * <pre>
 * message RTPControlMsg
 * {
 * }
 * </pre>
 */
class RTPControlMsg : public ::omnetpp::cMessage
{
  protected:

  private:
    void copy(const RTPControlMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RTPControlMsg&);

  public:
    RTPControlMsg(const char *name=nullptr, short kind=0);
    RTPControlMsg(const RTPControlMsg& other);
    virtual ~RTPControlMsg();
    RTPControlMsg& operator=(const RTPControlMsg& other);
    virtual RTPControlMsg *dup() const override {return new RTPControlMsg(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RTPControlMsg& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RTPControlMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg:65</tt> by nedtool.
 * <pre>
 * // base class
 * class RTPControlInfo
 * {
 *     short type \@enum(RTP_IFP_TYPE);
 * }
 * </pre>
 */
class RTPControlInfo : public ::omnetpp::cObject
{
  protected:
    short type;

  private:
    void copy(const RTPControlInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RTPControlInfo&);

  public:
    RTPControlInfo();
    RTPControlInfo(const RTPControlInfo& other);
    virtual ~RTPControlInfo();
    RTPControlInfo& operator=(const RTPControlInfo& other);
    virtual RTPControlInfo *dup() const override {return new RTPControlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual short getType() const;
    virtual void setType(short type);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RTPControlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RTPControlInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg:71</tt> by nedtool.
 * <pre>
 * // base class
 * class RTPSessionControlInfo extends RTPControlInfo
 * {
 *     uint32 ssrc;
 * }
 * </pre>
 */
class RTPSessionControlInfo : public ::inet::rtp::RTPControlInfo
{
  protected:
    uint32_t ssrc;

  private:
    void copy(const RTPSessionControlInfo& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RTPSessionControlInfo&);

  public:
    RTPSessionControlInfo();
    RTPSessionControlInfo(const RTPSessionControlInfo& other);
    virtual ~RTPSessionControlInfo();
    RTPSessionControlInfo& operator=(const RTPSessionControlInfo& other);
    virtual RTPSessionControlInfo *dup() const override {return new RTPSessionControlInfo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual uint32_t getSsrc() const;
    virtual void setSsrc(uint32_t ssrc);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RTPSessionControlInfo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RTPSessionControlInfo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg:78</tt> by nedtool.
 * <pre>
 * // App to ~RTP
 * class RTPCIEnterSession extends RTPControlInfo
 * {
 *     type = RTP_IFP_ENTER_SESSION;
 *     string commonName;
 *     string profileName;
 *     int bandwidth;
 *     IPv4Address destinationAddress;
 *     int port;
 * }
 * </pre>
 */
class RTPCIEnterSession : public ::inet::rtp::RTPControlInfo
{
  protected:
    ::omnetpp::opp_string commonName;
    ::omnetpp::opp_string profileName;
    int bandwidth;
    IPv4Address destinationAddress;
    int port;

  private:
    void copy(const RTPCIEnterSession& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RTPCIEnterSession&);

  public:
    RTPCIEnterSession();
    RTPCIEnterSession(const RTPCIEnterSession& other);
    virtual ~RTPCIEnterSession();
    RTPCIEnterSession& operator=(const RTPCIEnterSession& other);
    virtual RTPCIEnterSession *dup() const override {return new RTPCIEnterSession(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getCommonName() const;
    virtual void setCommonName(const char * commonName);
    virtual const char * getProfileName() const;
    virtual void setProfileName(const char * profileName);
    virtual int getBandwidth() const;
    virtual void setBandwidth(int bandwidth);
    virtual IPv4Address& getDestinationAddress();
    virtual const IPv4Address& getDestinationAddress() const {return const_cast<RTPCIEnterSession*>(this)->getDestinationAddress();}
    virtual void setDestinationAddress(const IPv4Address& destinationAddress);
    virtual int getPort() const;
    virtual void setPort(int port);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RTPCIEnterSession& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RTPCIEnterSession& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg:89</tt> by nedtool.
 * <pre>
 * // ~RTP to App
 * class RTPCISessionEntered extends RTPSessionControlInfo
 * {
 *     type = RTP_IFP_SESSION_ENTERED;
 * }
 * </pre>
 */
class RTPCISessionEntered : public ::inet::rtp::RTPSessionControlInfo
{
  protected:

  private:
    void copy(const RTPCISessionEntered& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RTPCISessionEntered&);

  public:
    RTPCISessionEntered();
    RTPCISessionEntered(const RTPCISessionEntered& other);
    virtual ~RTPCISessionEntered();
    RTPCISessionEntered& operator=(const RTPCISessionEntered& other);
    virtual RTPCISessionEntered *dup() const override {return new RTPCISessionEntered(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RTPCISessionEntered& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RTPCISessionEntered& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg:95</tt> by nedtool.
 * <pre>
 * // App to ~RTP
 * class RTPCISenderControl extends RTPSessionControlInfo
 * {
 *     type = RTP_IFP_SENDER_CONTROL;
 *     // from ~RTPSenderControlMessage:
 *     short command \@enum(RTPSenderControlMessageCommands);
 *     float commandParameter1;
 *     float commandParameter2;
 * }
 * </pre>
 */
class RTPCISenderControl : public ::inet::rtp::RTPSessionControlInfo
{
  protected:
    short command;
    float commandParameter1;
    float commandParameter2;

  private:
    void copy(const RTPCISenderControl& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RTPCISenderControl&);

  public:
    RTPCISenderControl();
    RTPCISenderControl(const RTPCISenderControl& other);
    virtual ~RTPCISenderControl();
    RTPCISenderControl& operator=(const RTPCISenderControl& other);
    virtual RTPCISenderControl *dup() const override {return new RTPCISenderControl(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual short getCommand() const;
    virtual void setCommand(short command);
    virtual float getCommandParameter1() const;
    virtual void setCommandParameter1(float commandParameter1);
    virtual float getCommandParameter2() const;
    virtual void setCommandParameter2(float commandParameter2);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RTPCISenderControl& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RTPCISenderControl& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg:105</tt> by nedtool.
 * <pre>
 * // ~RTP to App
 * class RTPCISenderStatus extends RTPSessionControlInfo
 * {
 *     type = RTP_IFP_SENDER_STATUS;
 *     // from ~RTPSenderStatusMessage:
 *     short status \@enum(RTPSenderStatus);
 *     uint32 timeStamp;
 * }
 * </pre>
 */
class RTPCISenderStatus : public ::inet::rtp::RTPSessionControlInfo
{
  protected:
    short status;
    uint32_t timeStamp;

  private:
    void copy(const RTPCISenderStatus& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RTPCISenderStatus&);

  public:
    RTPCISenderStatus();
    RTPCISenderStatus(const RTPCISenderStatus& other);
    virtual ~RTPCISenderStatus();
    RTPCISenderStatus& operator=(const RTPCISenderStatus& other);
    virtual RTPCISenderStatus *dup() const override {return new RTPCISenderStatus(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual short getStatus() const;
    virtual void setStatus(short status);
    virtual uint32_t getTimeStamp() const;
    virtual void setTimeStamp(uint32_t timeStamp);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RTPCISenderStatus& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RTPCISenderStatus& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg:114</tt> by nedtool.
 * <pre>
 * // App to ~RTP
 * class RTPCILeaveSession extends RTPControlInfo
 * {
 *     type = RTP_IFP_LEAVE_SESSION;
 *     // TODO do I need any sesson identifier?
 * }
 * </pre>
 */
class RTPCILeaveSession : public ::inet::rtp::RTPControlInfo
{
  protected:

  private:
    void copy(const RTPCILeaveSession& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RTPCILeaveSession&);

  public:
    RTPCILeaveSession();
    RTPCILeaveSession(const RTPCILeaveSession& other);
    virtual ~RTPCILeaveSession();
    RTPCILeaveSession& operator=(const RTPCILeaveSession& other);
    virtual RTPCILeaveSession *dup() const override {return new RTPCILeaveSession(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RTPCILeaveSession& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RTPCILeaveSession& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg:121</tt> by nedtool.
 * <pre>
 * // ~RTP to App
 * class RTPCISessionLeft extends RTPControlInfo
 * {
 *     type = RTP_IFP_SESSION_LEFT;
 *     // TODO do I need any sesson identifier?
 * }
 * </pre>
 */
class RTPCISessionLeft : public ::inet::rtp::RTPControlInfo
{
  protected:

  private:
    void copy(const RTPCISessionLeft& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RTPCISessionLeft&);

  public:
    RTPCISessionLeft();
    RTPCISessionLeft(const RTPCISessionLeft& other);
    virtual ~RTPCISessionLeft();
    RTPCISessionLeft& operator=(const RTPCISessionLeft& other);
    virtual RTPCISessionLeft *dup() const override {return new RTPCISessionLeft(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RTPCISessionLeft& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RTPCISessionLeft& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg:128</tt> by nedtool.
 * <pre>
 * // App to ~RTP
 * class RTPCICreateSenderModule extends RTPSessionControlInfo
 * {
 *     type = RTP_IFP_CREATE_SENDER_MODULE;
 *     int payloadType;
 *     string fileName;
 * }
 * </pre>
 */
class RTPCICreateSenderModule : public ::inet::rtp::RTPSessionControlInfo
{
  protected:
    int payloadType;
    ::omnetpp::opp_string fileName;

  private:
    void copy(const RTPCICreateSenderModule& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RTPCICreateSenderModule&);

  public:
    RTPCICreateSenderModule();
    RTPCICreateSenderModule(const RTPCICreateSenderModule& other);
    virtual ~RTPCICreateSenderModule();
    RTPCICreateSenderModule& operator=(const RTPCICreateSenderModule& other);
    virtual RTPCICreateSenderModule *dup() const override {return new RTPCICreateSenderModule(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getPayloadType() const;
    virtual void setPayloadType(int payloadType);
    virtual const char * getFileName() const;
    virtual void setFileName(const char * fileName);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RTPCICreateSenderModule& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RTPCICreateSenderModule& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg:136</tt> by nedtool.
 * <pre>
 * // ~RTP to App
 * class RTPCISenderModuleCreated extends RTPSessionControlInfo
 * {
 *     type = RTP_IFP_SENDER_MODULE_CREATED;
 * }
 * </pre>
 */
class RTPCISenderModuleCreated : public ::inet::rtp::RTPSessionControlInfo
{
  protected:

  private:
    void copy(const RTPCISenderModuleCreated& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RTPCISenderModuleCreated&);

  public:
    RTPCISenderModuleCreated();
    RTPCISenderModuleCreated(const RTPCISenderModuleCreated& other);
    virtual ~RTPCISenderModuleCreated();
    RTPCISenderModuleCreated& operator=(const RTPCISenderModuleCreated& other);
    virtual RTPCISenderModuleCreated *dup() const override {return new RTPCISenderModuleCreated(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RTPCISenderModuleCreated& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RTPCISenderModuleCreated& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg:142</tt> by nedtool.
 * <pre>
 * // App to ~RTP
 * class RTPCIDeleteSenderModule extends RTPSessionControlInfo
 * {
 *     type = RTP_IFP_DELETE_SENDER_MODULE;
 * }
 * </pre>
 */
class RTPCIDeleteSenderModule : public ::inet::rtp::RTPSessionControlInfo
{
  protected:

  private:
    void copy(const RTPCIDeleteSenderModule& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RTPCIDeleteSenderModule&);

  public:
    RTPCIDeleteSenderModule();
    RTPCIDeleteSenderModule(const RTPCIDeleteSenderModule& other);
    virtual ~RTPCIDeleteSenderModule();
    RTPCIDeleteSenderModule& operator=(const RTPCIDeleteSenderModule& other);
    virtual RTPCIDeleteSenderModule *dup() const override {return new RTPCIDeleteSenderModule(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RTPCIDeleteSenderModule& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RTPCIDeleteSenderModule& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>/home/veins/artery/extern/inet/src/inet/transportlayer/rtp/RTPInterfacePacket.msg:148</tt> by nedtool.
 * <pre>
 * // ~RTP to App
 * class RTPCISenderModuleDeleted extends RTPSessionControlInfo
 * {
 *     type = RTP_IFP_SENDER_MODULE_DELETED;
 * }
 * </pre>
 */
class RTPCISenderModuleDeleted : public ::inet::rtp::RTPSessionControlInfo
{
  protected:

  private:
    void copy(const RTPCISenderModuleDeleted& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RTPCISenderModuleDeleted&);

  public:
    RTPCISenderModuleDeleted();
    RTPCISenderModuleDeleted(const RTPCISenderModuleDeleted& other);
    virtual ~RTPCISenderModuleDeleted();
    RTPCISenderModuleDeleted& operator=(const RTPCISenderModuleDeleted& other);
    virtual RTPCISenderModuleDeleted *dup() const override {return new RTPCISenderModuleDeleted(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RTPCISenderModuleDeleted& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RTPCISenderModuleDeleted& obj) {obj.parsimUnpack(b);}

} // namespace rtp
} // namespace inet

#endif // ifndef __INET__RTP_RTPINTERFACEPACKET_M_H

